"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   agentsService: function() { return /* binding */ agentsService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nconst API_BASE_URL = \"http://localhost:8002\" || 0;\n// Create axios instance with default config\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    // Finite default timeout for normal requests (status, short analyses)\n    timeout: 15000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Response interceptor for error handling\napi.interceptors.response.use((response)=>response, (error)=>{\n    console.error(\"API Error:\", error);\n    return Promise.reject(error);\n});\nconst agentsService = {\n    // Get all available agents\n    async getAgents () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            // Transform backend agent data to frontend format\n            const agents = Object.entries(response.data.agents).map((param)=>{\n                let [key, agent] = param;\n                return {\n                    id: key,\n                    name: agent.name,\n                    description: agent.description,\n                    status: agent.status === \"online\" ? \"online\" : \"offline\",\n                    specialty: getSpecialtyFromCapabilities(agent.capabilities),\n                    actionLabel: getActionLabel(key),\n                    resultType: getResultType(key)\n                };\n            });\n            return agents;\n        } catch (error) {\n            console.error(\"Failed to fetch agents:\", error);\n            // Return default agents if API fails\n            return getDefaultAgents();\n        }\n    },\n    // Ryu Agent - Token Analysis\n    async analyzeToken (symbol) {\n        try {\n            var _data_entry_levels, _data_entry_levels1, _data_entry_levels2, _data_entry_levels3, _data_entry_levels4, _data_entry_levels5, _data_entry_levels6, _data_technical_analysis_rsi_14, _data_technical_analysis, _data_technical_analysis_macd_line, _data_technical_analysis1, _data_technical_analysis2, _data_scores, _data_scores1, _data_scores2, _data_scores3, _data_scores4;\n            console.log(\"\\uD83D\\uDD0D Requesting Ryu analysis for \".concat(symbol, \"...\"));\n            const response = await api.post(\"/api/agents/ryu/analyze\", {\n                symbol: symbol.toUpperCase(),\n                analysis_type: \"comprehensive\"\n            });\n            const data = response.data;\n            console.log(\"✅ Ryu analysis completed for \".concat(symbol));\n            return {\n                symbol: data.symbol,\n                action: data.recommendation || \"HOLD\",\n                confidence: data.confidence || 0.5,\n                currentPrice: data.current_price || 0,\n                entryRange: {\n                    min: ((_data_entry_levels = data.entry_levels) === null || _data_entry_levels === void 0 ? void 0 : _data_entry_levels.entry_range_low) || 0,\n                    max: ((_data_entry_levels1 = data.entry_levels) === null || _data_entry_levels1 === void 0 ? void 0 : _data_entry_levels1.entry_range_high) || 0\n                },\n                targets: {\n                    target1: ((_data_entry_levels2 = data.entry_levels) === null || _data_entry_levels2 === void 0 ? void 0 : _data_entry_levels2.target_1) || 0,\n                    target2: (_data_entry_levels3 = data.entry_levels) === null || _data_entry_levels3 === void 0 ? void 0 : _data_entry_levels3.target_2,\n                    target3: undefined\n                },\n                stopLoss: ((_data_entry_levels4 = data.entry_levels) === null || _data_entry_levels4 === void 0 ? void 0 : _data_entry_levels4.stop_loss) || 0,\n                riskRewardRatio: calculateRiskReward(data.current_price, (_data_entry_levels5 = data.entry_levels) === null || _data_entry_levels5 === void 0 ? void 0 : _data_entry_levels5.target_1, (_data_entry_levels6 = data.entry_levels) === null || _data_entry_levels6 === void 0 ? void 0 : _data_entry_levels6.stop_loss, data.recommendation),\n                analysis: {\n                    technical: \"RSI: \".concat(((_data_technical_analysis = data.technical_analysis) === null || _data_technical_analysis === void 0 ? void 0 : (_data_technical_analysis_rsi_14 = _data_technical_analysis.rsi_14) === null || _data_technical_analysis_rsi_14 === void 0 ? void 0 : _data_technical_analysis_rsi_14.toFixed(1)) || \"N/A\", \", MACD: \").concat(((_data_technical_analysis1 = data.technical_analysis) === null || _data_technical_analysis1 === void 0 ? void 0 : (_data_technical_analysis_macd_line = _data_technical_analysis1.macd_line) === null || _data_technical_analysis_macd_line === void 0 ? void 0 : _data_technical_analysis_macd_line.toFixed(4)) || \"N/A\", \", Trend: \").concat(((_data_technical_analysis2 = data.technical_analysis) === null || _data_technical_analysis2 === void 0 ? void 0 : _data_technical_analysis2.trend) || \"Unknown\"),\n                    fundamental: \"Market cap analysis and volume assessment completed\",\n                    sentiment: \"Market sentiment: \".concat(data.risk_assessment || \"Neutral\"),\n                    risk: \"Risk Level: \".concat(data.risk_assessment || \"Medium\")\n                },\n                scores: {\n                    technical: ((_data_scores = data.scores) === null || _data_scores === void 0 ? void 0 : _data_scores.technical) || 75,\n                    fundamental: ((_data_scores1 = data.scores) === null || _data_scores1 === void 0 ? void 0 : _data_scores1.overall) * 0.8 || 70,\n                    momentum: ((_data_scores2 = data.scores) === null || _data_scores2 === void 0 ? void 0 : _data_scores2.momentum) || 65,\n                    sentiment: ((_data_scores3 = data.scores) === null || _data_scores3 === void 0 ? void 0 : _data_scores3.volume) * 0.7 || 60,\n                    overall: ((_data_scores4 = data.scores) === null || _data_scores4 === void 0 ? void 0 : _data_scores4.overall) || 68\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            var _error_response, _error_response_data, _error_response1, _error_response_data1, _error_response2;\n            console.error(\"Token analysis failed:\", error);\n            // Handle specific API errors more gracefully\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail)) {\n                // Extract the meaningful error message from 404 responses\n                throw new Error(error.response.data.detail);\n            } else if ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data1 = _error_response2.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.detail) {\n                // Handle other API errors with detail messages\n                throw new Error(error.response.data.detail);\n            } else {\n                // Fallback for network or other errors\n                throw new Error(\"Failed to analyze \".concat(symbol, \": \").concat(error instanceof Error ? error.message : \"Network Error\"));\n            }\n        }\n    },\n    // Yuki Agent - Trade Scanner\n    async scanTrades () {\n        try {\n            console.log(\"⚡ Requesting Yuki trade scan...\");\n            const response = await api.post(\"/api/agents/yuki/scan\", {\n                scan_type: \"opportunities\",\n                pairs_limit: 500\n            }, {\n                // Disable timeout only for long-running Yuki scans\n                timeout: 0\n            });\n            const data = response.data;\n            console.log(\"✅ Yuki scan completed: \".concat(data.opportunities_found, \" opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        symbol: opp.symbol,\n                        direction: opp.direction,\n                        confidence: opp.confidence,\n                        entryPrice: opp.entry_price,\n                        target1: opp.target_1,\n                        target2: opp.target_2,\n                        stopLoss: opp.stop_loss,\n                        riskRewardRatio: opp.risk_reward_ratio,\n                        timeHorizon: opp.time_horizon,\n                        reasoning: opp.reasoning,\n                        keyFactors: opp.key_factors || [],\n                        expiresAt: opp.expires_at\n                    })),\n                totalScanned: data.total_scanned || 500,\n                bestOpportunity: data.opportunities[0] || null,\n                marketCondition: data.market_condition || \"Analyzed\",\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Trade scanning failed:\", error);\n            throw new Error(\"Failed to scan trades: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Yuki Agent - Progressive streaming scan (SSE)\n    streamTrades (onEvent) {\n        const url = \"\".concat(API_BASE_URL, \"/api/agents/yuki/scan/stream\");\n        const es = new EventSource(url);\n        const safeParse = (raw)=>{\n            try {\n                if (typeof raw === \"string\") return JSON.parse(raw);\n                return raw;\n            } catch (e) {\n                return raw;\n            }\n        };\n        es.addEventListener(\"progress\", (e)=>onEvent({\n                type: \"progress\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"opportunity\", (e)=>onEvent({\n                type: \"opportunity\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"complete\", (e)=>onEvent({\n                type: \"complete\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"error\", (e)=>onEvent({\n                type: \"error\",\n                data: safeParse(e.data || \"stream error\")\n            }));\n        // Return unsubscribe function\n        return ()=>es.close();\n    },\n    // Sakura Agent - Yield Opportunities\n    async getYieldOpportunities () {\n        try {\n            var _data_portfolio_recommendation_allocation, _data_portfolio_recommendation, _data_portfolio_recommendation1, _data_portfolio_recommendation2;\n            console.log(\"\\uD83C\\uDF38 Requesting Sakura yield analysis...\");\n            const response = await api.post(\"/api/agents/sakura/yield\", {\n                analysis_type: \"yield_farming\",\n                risk_preference: \"conservative\"\n            });\n            const data = response.data;\n            console.log(\"✅ Sakura analysis completed: \".concat(data.opportunities.length, \" yield opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        protocol: opp.protocol,\n                        asset: opp.asset,\n                        apy: opp.apy,\n                        tvl: opp.tvl,\n                        riskLevel: opp.risk_level,\n                        maturity: opp.maturity,\n                        minimumDeposit: opp.minimum_deposit,\n                        strategy: opp.strategy,\n                        projectedReturns: opp.projected_returns\n                    })),\n                totalTvlAnalyzed: data.total_tvl_analyzed || 0,\n                bestOpportunity: data.opportunities[0] || null,\n                portfolioRecommendation: {\n                    allocation: ((_data_portfolio_recommendation = data.portfolio_recommendation) === null || _data_portfolio_recommendation === void 0 ? void 0 : (_data_portfolio_recommendation_allocation = _data_portfolio_recommendation.allocation) === null || _data_portfolio_recommendation_allocation === void 0 ? void 0 : _data_portfolio_recommendation_allocation.map((alloc)=>({\n                            opportunity: {\n                                id: alloc.protocol.toLowerCase(),\n                                protocol: alloc.protocol,\n                                asset: \"Multi\",\n                                apy: alloc.apy_contribution * (100 / alloc.percentage),\n                                tvl: 0,\n                                riskLevel: \"LOW\",\n                                minimumDeposit: 100,\n                                strategy: \"Portfolio Allocation\",\n                                projectedReturns: {\n                                    monthly: alloc.apy_contribution / 12,\n                                    quarterly: alloc.apy_contribution / 4,\n                                    yearly: alloc.apy_contribution\n                                }\n                            },\n                            percentage: alloc.percentage\n                        }))) || [],\n                    totalProjectedApy: ((_data_portfolio_recommendation1 = data.portfolio_recommendation) === null || _data_portfolio_recommendation1 === void 0 ? void 0 : _data_portfolio_recommendation1.total_projected_apy) || 0,\n                    riskScore: ((_data_portfolio_recommendation2 = data.portfolio_recommendation) === null || _data_portfolio_recommendation2 === void 0 ? void 0 : _data_portfolio_recommendation2.risk_score) || 0.25\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Yield analysis failed:\", error);\n            throw new Error(\"Failed to get yield opportunities: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Get integration status\n    async getStatus () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to get status:\", error);\n            return null;\n        }\n    }\n};\n// Helper functions\nfunction getSpecialtyFromCapabilities(capabilities) {\n    if (capabilities.includes(\"token_analysis\")) return \"Token Analysis\";\n    if (capabilities.includes(\"market_scanning\")) return \"Trade Scanner\";\n    if (capabilities.includes(\"yield_optimization\")) return \"Yield Farming\";\n    return \"AI Analysis\";\n}\nfunction getActionLabel(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"Analyze Token\";\n        case \"yuki\":\n            return \"Find Trades\";\n        case \"sakura\":\n            return \"Get Yield Opportunities\";\n        default:\n            return \"Execute\";\n    }\n}\nfunction getResultType(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"AI Token Analysis Report\";\n        case \"yuki\":\n            return \"Market Opportunities\";\n        case \"sakura\":\n            return \"DeFi Yield Options\";\n        default:\n            return \"Analysis Results\";\n    }\n}\nfunction getDefaultAgents() {\n    return [\n        {\n            id: \"ryu\",\n            name: \"Ryu Agent\",\n            description: \"Professional token analysis with comprehensive AI scoring and risk assessment.\",\n            status: \"online\",\n            specialty: \"Token Analysis\",\n            actionLabel: \"Analyze Token\",\n            resultType: \"AI Token Analysis Report\"\n        },\n        {\n            id: \"yuki\",\n            name: \"Yuki Agent\",\n            description: \"Advanced trade scanner for high-frequency opportunities across 500+ trading pairs.\",\n            status: \"online\",\n            specialty: \"Trade Scanner\",\n            actionLabel: \"Find Trades\",\n            resultType: \"Market Opportunities\"\n        },\n        {\n            id: \"sakura\",\n            name: \"Sakura Agent\",\n            description: \"Conservative DeFi yield farming with Pendle integration and risk-adjusted returns.\",\n            status: \"online\",\n            specialty: \"Yield Farming\",\n            actionLabel: \"Get Yield Opportunities\",\n            resultType: \"DeFi Yield Options\"\n        }\n    ];\n}\nfunction calculateRiskReward(entry, target, stop, direction) {\n    try {\n        if (!entry || !target || !stop) return 0;\n        let reward;\n        let risk;\n        if (direction === \"LONG\") {\n            reward = target - entry;\n            risk = entry - stop;\n        } else {\n            reward = entry - target;\n            risk = stop - entry;\n        }\n        if (risk <= 0) return 0;\n        return reward / risk;\n    } catch (e) {\n        return 0;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTztRQUNuQixLQUFLO1lBQVEsT0FBTztRQUNwQixLQUFLO1lBQVUsT0FBTztRQUN0QjtZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUVBLFNBQVN2SDtJQUNQLE9BQU87UUFDTDtZQUNFWCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7UUFDQTtZQUNFVCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7UUFDQTtZQUNFVCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7S0FDRDtBQUNIO0FBRUEsU0FBUzhCLG9CQUFvQjRGLEtBQWEsRUFBRUMsTUFBYyxFQUFFQyxJQUFZLEVBQUVsRSxTQUFpQjtJQUN6RixJQUFJO1FBQ0YsSUFBSSxDQUFDZ0UsU0FBUyxDQUFDQyxVQUFVLENBQUNDLE1BQU0sT0FBTztRQUV2QyxJQUFJQztRQUNKLElBQUlwRjtRQUVKLElBQUlpQixjQUFjLFFBQVE7WUFDeEJtRSxTQUFTRixTQUFTRDtZQUNsQmpGLE9BQU9pRixRQUFRRTtRQUNqQixPQUFPO1lBQ0xDLFNBQVNILFFBQVFDO1lBQ2pCbEYsT0FBT21GLE9BQU9GO1FBQ2hCO1FBRUEsSUFBSWpGLFFBQVEsR0FBRyxPQUFPO1FBQ3RCLE9BQU9vRixTQUFTcEY7SUFDbEIsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFQSwrREFBZXhFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2FwaS50cz85NTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBBZ2VudCwgVG9rZW5BbmFseXNpc1Jlc3VsdCwgVHJhZGVTY2FuUmVzdWx0LCBZaWVsZEFuYWx5c2lzUmVzdWx0IH0gZnJvbSAnQC90eXBlcy9hZ2VudHMnO1xuXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDEnO1xuXG4vLyBDcmVhdGUgYXhpb3MgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IGNvbmZpZ1xuY29uc3QgYXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxuICAvLyBGaW5pdGUgZGVmYXVsdCB0aW1lb3V0IGZvciBub3JtYWwgcmVxdWVzdHMgKHN0YXR1cywgc2hvcnQgYW5hbHlzZXMpXG4gIHRpbWVvdXQ6IDE1MDAwLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfSxcbn0pO1xuXG4vLyBSZXNwb25zZSBpbnRlcmNlcHRvciBmb3IgZXJyb3IgaGFuZGxpbmdcbmFwaS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxuICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLFxuICAoZXJyb3IpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCBhZ2VudHNTZXJ2aWNlID0ge1xuICAvLyBHZXQgYWxsIGF2YWlsYWJsZSBhZ2VudHNcbiAgYXN5bmMgZ2V0QWdlbnRzKCk6IFByb21pc2U8QWdlbnRbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9hcGkvYWdlbnRzL3N0YXR1cycpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gYmFja2VuZCBhZ2VudCBkYXRhIHRvIGZyb250ZW5kIGZvcm1hdFxuICAgICAgY29uc3QgYWdlbnRzOiBBZ2VudFtdID0gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZGF0YS5hZ2VudHMpLm1hcCgoW2tleSwgYWdlbnRdOiBbc3RyaW5nLCBhbnldKSA9PiAoe1xuICAgICAgICBpZDoga2V5LFxuICAgICAgICBuYW1lOiBhZ2VudC5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogYWdlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgIHN0YXR1czogYWdlbnQuc3RhdHVzID09PSAnb25saW5lJyA/ICdvbmxpbmUnIGFzIGNvbnN0IDogJ29mZmxpbmUnIGFzIGNvbnN0LFxuICAgICAgICBzcGVjaWFsdHk6IGdldFNwZWNpYWx0eUZyb21DYXBhYmlsaXRpZXMoYWdlbnQuY2FwYWJpbGl0aWVzKSxcbiAgICAgICAgYWN0aW9uTGFiZWw6IGdldEFjdGlvbkxhYmVsKGtleSksXG4gICAgICAgIHJlc3VsdFR5cGU6IGdldFJlc3VsdFR5cGUoa2V5KSxcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGFnZW50cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGFnZW50czonLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gZGVmYXVsdCBhZ2VudHMgaWYgQVBJIGZhaWxzXG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdEFnZW50cygpO1xuICAgIH1cbiAgfSxcblxuICAvLyBSeXUgQWdlbnQgLSBUb2tlbiBBbmFseXNpc1xuICBhc3luYyBhbmFseXplVG9rZW4oc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPFRva2VuQW5hbHlzaXNSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflI0gUmVxdWVzdGluZyBSeXUgYW5hbHlzaXMgZm9yICR7c3ltYm9sfS4uLmApO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXBpL2FnZW50cy9yeXUvYW5hbHl6ZScsIHtcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wudG9VcHBlckNhc2UoKSxcbiAgICAgICAgYW5hbHlzaXNfdHlwZTogJ2NvbXByZWhlbnNpdmUnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUnl1IGFuYWx5c2lzIGNvbXBsZXRlZCBmb3IgJHtzeW1ib2x9YCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN5bWJvbDogZGF0YS5zeW1ib2wsXG4gICAgICAgIGFjdGlvbjogZGF0YS5yZWNvbW1lbmRhdGlvbiB8fCAnSE9MRCcsXG4gICAgICAgIGNvbmZpZGVuY2U6IGRhdGEuY29uZmlkZW5jZSB8fCAwLjUsXG4gICAgICAgIGN1cnJlbnRQcmljZTogZGF0YS5jdXJyZW50X3ByaWNlIHx8IDAsXG4gICAgICAgIGVudHJ5UmFuZ2U6IHtcbiAgICAgICAgICBtaW46IGRhdGEuZW50cnlfbGV2ZWxzPy5lbnRyeV9yYW5nZV9sb3cgfHwgMCxcbiAgICAgICAgICBtYXg6IGRhdGEuZW50cnlfbGV2ZWxzPy5lbnRyeV9yYW5nZV9oaWdoIHx8IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldHM6IHtcbiAgICAgICAgICB0YXJnZXQxOiBkYXRhLmVudHJ5X2xldmVscz8udGFyZ2V0XzEgfHwgMCxcbiAgICAgICAgICB0YXJnZXQyOiBkYXRhLmVudHJ5X2xldmVscz8udGFyZ2V0XzIsXG4gICAgICAgICAgdGFyZ2V0MzogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICBzdG9wTG9zczogZGF0YS5lbnRyeV9sZXZlbHM/LnN0b3BfbG9zcyB8fCAwLFxuICAgICAgICByaXNrUmV3YXJkUmF0aW86IGNhbGN1bGF0ZVJpc2tSZXdhcmQoXG4gICAgICAgICAgZGF0YS5jdXJyZW50X3ByaWNlLFxuICAgICAgICAgIGRhdGEuZW50cnlfbGV2ZWxzPy50YXJnZXRfMSxcbiAgICAgICAgICBkYXRhLmVudHJ5X2xldmVscz8uc3RvcF9sb3NzLFxuICAgICAgICAgIGRhdGEucmVjb21tZW5kYXRpb25cbiAgICAgICAgKSxcbiAgICAgICAgYW5hbHlzaXM6IHtcbiAgICAgICAgICB0ZWNobmljYWw6IGBSU0k6ICR7ZGF0YS50ZWNobmljYWxfYW5hbHlzaXM/LnJzaV8xND8udG9GaXhlZCgxKSB8fCAnTi9BJ30sIE1BQ0Q6ICR7ZGF0YS50ZWNobmljYWxfYW5hbHlzaXM/Lm1hY2RfbGluZT8udG9GaXhlZCg0KSB8fCAnTi9BJ30sIFRyZW5kOiAke2RhdGEudGVjaG5pY2FsX2FuYWx5c2lzPy50cmVuZCB8fCAnVW5rbm93bid9YCxcbiAgICAgICAgICBmdW5kYW1lbnRhbDogYE1hcmtldCBjYXAgYW5hbHlzaXMgYW5kIHZvbHVtZSBhc3Nlc3NtZW50IGNvbXBsZXRlZGAsXG4gICAgICAgICAgc2VudGltZW50OiBgTWFya2V0IHNlbnRpbWVudDogJHtkYXRhLnJpc2tfYXNzZXNzbWVudCB8fCAnTmV1dHJhbCd9YCxcbiAgICAgICAgICByaXNrOiBgUmlzayBMZXZlbDogJHtkYXRhLnJpc2tfYXNzZXNzbWVudCB8fCAnTWVkaXVtJ31gLFxuICAgICAgICB9LFxuICAgICAgICBzY29yZXM6IHtcbiAgICAgICAgICB0ZWNobmljYWw6IGRhdGEuc2NvcmVzPy50ZWNobmljYWwgfHwgNzUsXG4gICAgICAgICAgZnVuZGFtZW50YWw6IGRhdGEuc2NvcmVzPy5vdmVyYWxsICogMC44IHx8IDcwLFxuICAgICAgICAgIG1vbWVudHVtOiBkYXRhLnNjb3Jlcz8ubW9tZW50dW0gfHwgNjUsXG4gICAgICAgICAgc2VudGltZW50OiBkYXRhLnNjb3Jlcz8udm9sdW1lICogMC43IHx8IDYwLFxuICAgICAgICAgIG92ZXJhbGw6IGRhdGEuc2NvcmVzPy5vdmVyYWxsIHx8IDY4LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gYW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcblxuICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIEFQSSBlcnJvcnMgbW9yZSBncmFjZWZ1bGx5XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDA0ICYmIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWwpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlIGZyb20gNDA0IHJlc3BvbnNlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWwpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlsKSB7XG4gICAgICAgIC8vIEhhbmRsZSBvdGhlciBBUEkgZXJyb3JzIHdpdGggZGV0YWlsIG1lc3NhZ2VzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgbmV0d29yayBvciBvdGhlciBlcnJvcnNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYW5hbHl6ZSAke3N5bWJvbH06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnTmV0d29yayBFcnJvcid9YCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFl1a2kgQWdlbnQgLSBUcmFkZSBTY2FubmVyXG4gIGFzeW5jIHNjYW5UcmFkZXMoKTogUHJvbWlzZTxUcmFkZVNjYW5SZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBSZXF1ZXN0aW5nIFl1a2kgdHJhZGUgc2Nhbi4uLicpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KFxuICAgICAgICAnL2FwaS9hZ2VudHMveXVraS9zY2FuJyxcbiAgICAgICAge1xuICAgICAgICAgIHNjYW5fdHlwZTogJ29wcG9ydHVuaXRpZXMnLFxuICAgICAgICAgIHBhaXJzX2xpbWl0OiA1MDBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIERpc2FibGUgdGltZW91dCBvbmx5IGZvciBsb25nLXJ1bm5pbmcgWXVraSBzY2Fuc1xuICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFl1a2kgc2NhbiBjb21wbGV0ZWQ6ICR7ZGF0YS5vcHBvcnR1bml0aWVzX2ZvdW5kfSBvcHBvcnR1bml0aWVzIGZvdW5kYCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wcG9ydHVuaXRpZXM6IGRhdGEub3Bwb3J0dW5pdGllcy5tYXAoKG9wcDogYW55KSA9PiAoe1xuICAgICAgICAgIGlkOiBvcHAuaWQsXG4gICAgICAgICAgc3ltYm9sOiBvcHAuc3ltYm9sLFxuICAgICAgICAgIGRpcmVjdGlvbjogb3BwLmRpcmVjdGlvbixcbiAgICAgICAgICBjb25maWRlbmNlOiBvcHAuY29uZmlkZW5jZSxcbiAgICAgICAgICBlbnRyeVByaWNlOiBvcHAuZW50cnlfcHJpY2UsXG4gICAgICAgICAgdGFyZ2V0MTogb3BwLnRhcmdldF8xLFxuICAgICAgICAgIHRhcmdldDI6IG9wcC50YXJnZXRfMixcbiAgICAgICAgICBzdG9wTG9zczogb3BwLnN0b3BfbG9zcyxcbiAgICAgICAgICByaXNrUmV3YXJkUmF0aW86IG9wcC5yaXNrX3Jld2FyZF9yYXRpbyxcbiAgICAgICAgICB0aW1lSG9yaXpvbjogb3BwLnRpbWVfaG9yaXpvbixcbiAgICAgICAgICByZWFzb25pbmc6IG9wcC5yZWFzb25pbmcsXG4gICAgICAgICAga2V5RmFjdG9yczogb3BwLmtleV9mYWN0b3JzIHx8IFtdLFxuICAgICAgICAgIGV4cGlyZXNBdDogb3BwLmV4cGlyZXNfYXQsXG4gICAgICAgIH0pKSxcbiAgICAgICAgdG90YWxTY2FubmVkOiBkYXRhLnRvdGFsX3NjYW5uZWQgfHwgNTAwLFxuICAgICAgICBiZXN0T3Bwb3J0dW5pdHk6IGRhdGEub3Bwb3J0dW5pdGllc1swXSB8fCBudWxsLFxuICAgICAgICBtYXJrZXRDb25kaXRpb246IGRhdGEubWFya2V0X2NvbmRpdGlvbiB8fCAnQW5hbHl6ZWQnLFxuICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RyYWRlIHNjYW5uaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzY2FuIHRyYWRlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gWXVraSBBZ2VudCAtIFByb2dyZXNzaXZlIHN0cmVhbWluZyBzY2FuIChTU0UpXG4gIHN0cmVhbVRyYWRlcyhvbkV2ZW50OiAoZXZ0OiB7IHR5cGU6ICdwcm9ncmVzcycgfCAnb3Bwb3J0dW5pdHknIHwgJ2NvbXBsZXRlJyB8ICdlcnJvcic7IGRhdGE6IGFueSB9KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0VfVVJMfS9hcGkvYWdlbnRzL3l1a2kvc2Nhbi9zdHJlYW1gO1xuICAgIGNvbnN0IGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG5cbiAgICBjb25zdCBzYWZlUGFyc2UgPSAocmF3OiBhbnkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlcy5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChlOiBNZXNzYWdlRXZlbnQpID0+IG9uRXZlbnQoeyB0eXBlOiAncHJvZ3Jlc3MnLCBkYXRhOiBzYWZlUGFyc2UoZS5kYXRhKSB9KSk7XG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcignb3Bwb3J0dW5pdHknLCAoZTogTWVzc2FnZUV2ZW50KSA9PiBvbkV2ZW50KHsgdHlwZTogJ29wcG9ydHVuaXR5JywgZGF0YTogc2FmZVBhcnNlKGUuZGF0YSkgfSkpO1xuICAgIGVzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgKGU6IE1lc3NhZ2VFdmVudCkgPT4gb25FdmVudCh7IHR5cGU6ICdjb21wbGV0ZScsIGRhdGE6IHNhZmVQYXJzZShlLmRhdGEpIH0pKTtcbiAgICBlcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChlOiBNZXNzYWdlRXZlbnQpID0+IG9uRXZlbnQoeyB0eXBlOiAnZXJyb3InLCBkYXRhOiBzYWZlUGFyc2UoKGUgYXMgYW55KS5kYXRhIHx8ICdzdHJlYW0gZXJyb3InKSB9KSk7XG5cbiAgICAvLyBSZXR1cm4gdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4gZXMuY2xvc2UoKTtcbiAgfSxcblxuICAvLyBTYWt1cmEgQWdlbnQgLSBZaWVsZCBPcHBvcnR1bml0aWVzXG4gIGFzeW5jIGdldFlpZWxkT3Bwb3J0dW5pdGllcygpOiBQcm9taXNlPFlpZWxkQW5hbHlzaXNSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CfjLggUmVxdWVzdGluZyBTYWt1cmEgeWllbGQgYW5hbHlzaXMuLi4nKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2FwaS9hZ2VudHMvc2FrdXJhL3lpZWxkJywge1xuICAgICAgICBhbmFseXNpc190eXBlOiAneWllbGRfZmFybWluZycsXG4gICAgICAgIHJpc2tfcHJlZmVyZW5jZTogJ2NvbnNlcnZhdGl2ZSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBTYWt1cmEgYW5hbHlzaXMgY29tcGxldGVkOiAke2RhdGEub3Bwb3J0dW5pdGllcy5sZW5ndGh9IHlpZWxkIG9wcG9ydHVuaXRpZXMgZm91bmRgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3Bwb3J0dW5pdGllczogZGF0YS5vcHBvcnR1bml0aWVzLm1hcCgob3BwOiBhbnkpID0+ICh7XG4gICAgICAgICAgaWQ6IG9wcC5pZCxcbiAgICAgICAgICBwcm90b2NvbDogb3BwLnByb3RvY29sLFxuICAgICAgICAgIGFzc2V0OiBvcHAuYXNzZXQsXG4gICAgICAgICAgYXB5OiBvcHAuYXB5LFxuICAgICAgICAgIHR2bDogb3BwLnR2bCxcbiAgICAgICAgICByaXNrTGV2ZWw6IG9wcC5yaXNrX2xldmVsLFxuICAgICAgICAgIG1hdHVyaXR5OiBvcHAubWF0dXJpdHksXG4gICAgICAgICAgbWluaW11bURlcG9zaXQ6IG9wcC5taW5pbXVtX2RlcG9zaXQsXG4gICAgICAgICAgc3RyYXRlZ3k6IG9wcC5zdHJhdGVneSxcbiAgICAgICAgICBwcm9qZWN0ZWRSZXR1cm5zOiBvcHAucHJvamVjdGVkX3JldHVybnMsXG4gICAgICAgIH0pKSxcbiAgICAgICAgdG90YWxUdmxBbmFseXplZDogZGF0YS50b3RhbF90dmxfYW5hbHl6ZWQgfHwgMCxcbiAgICAgICAgYmVzdE9wcG9ydHVuaXR5OiBkYXRhLm9wcG9ydHVuaXRpZXNbMF0gfHwgbnVsbCxcbiAgICAgICAgcG9ydGZvbGlvUmVjb21tZW5kYXRpb246IHtcbiAgICAgICAgICBhbGxvY2F0aW9uOiBkYXRhLnBvcnRmb2xpb19yZWNvbW1lbmRhdGlvbj8uYWxsb2NhdGlvbj8ubWFwKChhbGxvYzogYW55KSA9PiAoe1xuICAgICAgICAgICAgb3Bwb3J0dW5pdHk6IHtcbiAgICAgICAgICAgICAgaWQ6IGFsbG9jLnByb3RvY29sLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIHByb3RvY29sOiBhbGxvYy5wcm90b2NvbCxcbiAgICAgICAgICAgICAgYXNzZXQ6ICdNdWx0aScsXG4gICAgICAgICAgICAgIGFweTogYWxsb2MuYXB5X2NvbnRyaWJ1dGlvbiAqICgxMDAgLyBhbGxvYy5wZXJjZW50YWdlKSxcbiAgICAgICAgICAgICAgdHZsOiAwLFxuICAgICAgICAgICAgICByaXNrTGV2ZWw6ICdMT1cnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICBtaW5pbXVtRGVwb3NpdDogMTAwLFxuICAgICAgICAgICAgICBzdHJhdGVneTogJ1BvcnRmb2xpbyBBbGxvY2F0aW9uJyxcbiAgICAgICAgICAgICAgcHJvamVjdGVkUmV0dXJuczoge1xuICAgICAgICAgICAgICAgIG1vbnRobHk6IGFsbG9jLmFweV9jb250cmlidXRpb24gLyAxMixcbiAgICAgICAgICAgICAgICBxdWFydGVybHk6IGFsbG9jLmFweV9jb250cmlidXRpb24gLyA0LFxuICAgICAgICAgICAgICAgIHllYXJseTogYWxsb2MuYXB5X2NvbnRyaWJ1dGlvbixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBhbGxvYy5wZXJjZW50YWdlLFxuICAgICAgICAgIH0pKSB8fCBbXSxcbiAgICAgICAgICB0b3RhbFByb2plY3RlZEFweTogZGF0YS5wb3J0Zm9saW9fcmVjb21tZW5kYXRpb24/LnRvdGFsX3Byb2plY3RlZF9hcHkgfHwgMCxcbiAgICAgICAgICByaXNrU2NvcmU6IGRhdGEucG9ydGZvbGlvX3JlY29tbWVuZGF0aW9uPy5yaXNrX3Njb3JlIHx8IDAuMjUsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignWWllbGQgYW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB5aWVsZCBvcHBvcnR1bml0aWVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgaW50ZWdyYXRpb24gc3RhdHVzXG4gIGFzeW5jIGdldFN0YXR1cygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvYXBpL2FnZW50cy9zdGF0dXMnKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHN0YXR1czonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBnZXRTcGVjaWFsdHlGcm9tQ2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAoY2FwYWJpbGl0aWVzLmluY2x1ZGVzKCd0b2tlbl9hbmFseXNpcycpKSByZXR1cm4gJ1Rva2VuIEFuYWx5c2lzJztcbiAgaWYgKGNhcGFiaWxpdGllcy5pbmNsdWRlcygnbWFya2V0X3NjYW5uaW5nJykpIHJldHVybiAnVHJhZGUgU2Nhbm5lcic7XG4gIGlmIChjYXBhYmlsaXRpZXMuaW5jbHVkZXMoJ3lpZWxkX29wdGltaXphdGlvbicpKSByZXR1cm4gJ1lpZWxkIEZhcm1pbmcnO1xuICByZXR1cm4gJ0FJIEFuYWx5c2lzJztcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uTGFiZWwoYWdlbnRJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgc3dpdGNoIChhZ2VudElkKSB7XG4gICAgY2FzZSAncnl1JzogcmV0dXJuICdBbmFseXplIFRva2VuJztcbiAgICBjYXNlICd5dWtpJzogcmV0dXJuICdGaW5kIFRyYWRlcyc7XG4gICAgY2FzZSAnc2FrdXJhJzogcmV0dXJuICdHZXQgWWllbGQgT3Bwb3J0dW5pdGllcyc7XG4gICAgZGVmYXVsdDogcmV0dXJuICdFeGVjdXRlJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXN1bHRUeXBlKGFnZW50SWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWdlbnRJZCkge1xuICAgIGNhc2UgJ3J5dSc6IHJldHVybiAnQUkgVG9rZW4gQW5hbHlzaXMgUmVwb3J0JztcbiAgICBjYXNlICd5dWtpJzogcmV0dXJuICdNYXJrZXQgT3Bwb3J0dW5pdGllcyc7XG4gICAgY2FzZSAnc2FrdXJhJzogcmV0dXJuICdEZUZpIFlpZWxkIE9wdGlvbnMnO1xuICAgIGRlZmF1bHQ6IHJldHVybiAnQW5hbHlzaXMgUmVzdWx0cyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFnZW50cygpOiBBZ2VudFtdIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBpZDogJ3J5dScsXG4gICAgICBuYW1lOiAnUnl1IEFnZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUHJvZmVzc2lvbmFsIHRva2VuIGFuYWx5c2lzIHdpdGggY29tcHJlaGVuc2l2ZSBBSSBzY29yaW5nIGFuZCByaXNrIGFzc2Vzc21lbnQuJyxcbiAgICAgIHN0YXR1czogJ29ubGluZScsXG4gICAgICBzcGVjaWFsdHk6ICdUb2tlbiBBbmFseXNpcycsXG4gICAgICBhY3Rpb25MYWJlbDogJ0FuYWx5emUgVG9rZW4nLFxuICAgICAgcmVzdWx0VHlwZTogJ0FJIFRva2VuIEFuYWx5c2lzIFJlcG9ydCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3l1a2knLFxuICAgICAgbmFtZTogJ1l1a2kgQWdlbnQnLFxuICAgICAgZGVzY3JpcHRpb246ICdBZHZhbmNlZCB0cmFkZSBzY2FubmVyIGZvciBoaWdoLWZyZXF1ZW5jeSBvcHBvcnR1bml0aWVzIGFjcm9zcyA1MDArIHRyYWRpbmcgcGFpcnMuJyxcbiAgICAgIHN0YXR1czogJ29ubGluZScsXG4gICAgICBzcGVjaWFsdHk6ICdUcmFkZSBTY2FubmVyJyxcbiAgICAgIGFjdGlvbkxhYmVsOiAnRmluZCBUcmFkZXMnLFxuICAgICAgcmVzdWx0VHlwZTogJ01hcmtldCBPcHBvcnR1bml0aWVzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnc2FrdXJhJyxcbiAgICAgIG5hbWU6ICdTYWt1cmEgQWdlbnQnLFxuICAgICAgZGVzY3JpcHRpb246ICdDb25zZXJ2YXRpdmUgRGVGaSB5aWVsZCBmYXJtaW5nIHdpdGggUGVuZGxlIGludGVncmF0aW9uIGFuZCByaXNrLWFkanVzdGVkIHJldHVybnMuJyxcbiAgICAgIHN0YXR1czogJ29ubGluZScsXG4gICAgICBzcGVjaWFsdHk6ICdZaWVsZCBGYXJtaW5nJyxcbiAgICAgIGFjdGlvbkxhYmVsOiAnR2V0IFlpZWxkIE9wcG9ydHVuaXRpZXMnLFxuICAgICAgcmVzdWx0VHlwZTogJ0RlRmkgWWllbGQgT3B0aW9ucycsXG4gICAgfSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlza1Jld2FyZChlbnRyeTogbnVtYmVyLCB0YXJnZXQ6IG51bWJlciwgc3RvcDogbnVtYmVyLCBkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlciB7XG4gIHRyeSB7XG4gICAgaWYgKCFlbnRyeSB8fCAhdGFyZ2V0IHx8ICFzdG9wKSByZXR1cm4gMDtcblxuICAgIGxldCByZXdhcmQ6IG51bWJlcjtcbiAgICBsZXQgcmlzazogbnVtYmVyO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ0xPTkcnKSB7XG4gICAgICByZXdhcmQgPSB0YXJnZXQgLSBlbnRyeTtcbiAgICAgIHJpc2sgPSBlbnRyeSAtIHN0b3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJld2FyZCA9IGVudHJ5IC0gdGFyZ2V0O1xuICAgICAgcmlzayA9IHN0b3AgLSBlbnRyeTtcbiAgICB9XG5cbiAgICBpZiAocmlzayA8PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gcmV3YXJkIC8gcmlzaztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBpOyJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVzcG9uc2UiLCJ1c2UiLCJlcnJvciIsImNvbnNvbGUiLCJQcm9taXNlIiwicmVqZWN0IiwiYWdlbnRzU2VydmljZSIsImdldEFnZW50cyIsImdldCIsImFnZW50cyIsIk9iamVjdCIsImVudHJpZXMiLCJkYXRhIiwibWFwIiwia2V5IiwiYWdlbnQiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInN0YXR1cyIsInNwZWNpYWx0eSIsImdldFNwZWNpYWx0eUZyb21DYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXRpZXMiLCJhY3Rpb25MYWJlbCIsImdldEFjdGlvbkxhYmVsIiwicmVzdWx0VHlwZSIsImdldFJlc3VsdFR5cGUiLCJnZXREZWZhdWx0QWdlbnRzIiwiYW5hbHl6ZVRva2VuIiwic3ltYm9sIiwibG9nIiwicG9zdCIsInRvVXBwZXJDYXNlIiwiYW5hbHlzaXNfdHlwZSIsImFjdGlvbiIsInJlY29tbWVuZGF0aW9uIiwiY29uZmlkZW5jZSIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRfcHJpY2UiLCJlbnRyeVJhbmdlIiwibWluIiwiZW50cnlfbGV2ZWxzIiwiZW50cnlfcmFuZ2VfbG93IiwibWF4IiwiZW50cnlfcmFuZ2VfaGlnaCIsInRhcmdldHMiLCJ0YXJnZXQxIiwidGFyZ2V0XzEiLCJ0YXJnZXQyIiwidGFyZ2V0XzIiLCJ0YXJnZXQzIiwidW5kZWZpbmVkIiwic3RvcExvc3MiLCJzdG9wX2xvc3MiLCJyaXNrUmV3YXJkUmF0aW8iLCJjYWxjdWxhdGVSaXNrUmV3YXJkIiwiYW5hbHlzaXMiLCJ0ZWNobmljYWwiLCJ0ZWNobmljYWxfYW5hbHlzaXMiLCJyc2lfMTQiLCJ0b0ZpeGVkIiwibWFjZF9saW5lIiwidHJlbmQiLCJmdW5kYW1lbnRhbCIsInNlbnRpbWVudCIsInJpc2tfYXNzZXNzbWVudCIsInJpc2siLCJzY29yZXMiLCJvdmVyYWxsIiwibW9tZW50dW0iLCJ2b2x1bWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkZXRhaWwiLCJFcnJvciIsIm1lc3NhZ2UiLCJzY2FuVHJhZGVzIiwic2Nhbl90eXBlIiwicGFpcnNfbGltaXQiLCJvcHBvcnR1bml0aWVzX2ZvdW5kIiwib3Bwb3J0dW5pdGllcyIsIm9wcCIsImRpcmVjdGlvbiIsImVudHJ5UHJpY2UiLCJlbnRyeV9wcmljZSIsInJpc2tfcmV3YXJkX3JhdGlvIiwidGltZUhvcml6b24iLCJ0aW1lX2hvcml6b24iLCJyZWFzb25pbmciLCJrZXlGYWN0b3JzIiwia2V5X2ZhY3RvcnMiLCJleHBpcmVzQXQiLCJleHBpcmVzX2F0IiwidG90YWxTY2FubmVkIiwidG90YWxfc2Nhbm5lZCIsImJlc3RPcHBvcnR1bml0eSIsIm1hcmtldENvbmRpdGlvbiIsIm1hcmtldF9jb25kaXRpb24iLCJzdHJlYW1UcmFkZXMiLCJvbkV2ZW50IiwidXJsIiwiZXMiLCJFdmVudFNvdXJjZSIsInNhZmVQYXJzZSIsInJhdyIsIkpTT04iLCJwYXJzZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwidHlwZSIsImNsb3NlIiwiZ2V0WWllbGRPcHBvcnR1bml0aWVzIiwicmlza19wcmVmZXJlbmNlIiwibGVuZ3RoIiwicHJvdG9jb2wiLCJhc3NldCIsImFweSIsInR2bCIsInJpc2tMZXZlbCIsInJpc2tfbGV2ZWwiLCJtYXR1cml0eSIsIm1pbmltdW1EZXBvc2l0IiwibWluaW11bV9kZXBvc2l0Iiwic3RyYXRlZ3kiLCJwcm9qZWN0ZWRSZXR1cm5zIiwicHJvamVjdGVkX3JldHVybnMiLCJ0b3RhbFR2bEFuYWx5emVkIiwidG90YWxfdHZsX2FuYWx5emVkIiwicG9ydGZvbGlvUmVjb21tZW5kYXRpb24iLCJhbGxvY2F0aW9uIiwicG9ydGZvbGlvX3JlY29tbWVuZGF0aW9uIiwiYWxsb2MiLCJvcHBvcnR1bml0eSIsInRvTG93ZXJDYXNlIiwiYXB5X2NvbnRyaWJ1dGlvbiIsInBlcmNlbnRhZ2UiLCJtb250aGx5IiwicXVhcnRlcmx5IiwieWVhcmx5IiwidG90YWxQcm9qZWN0ZWRBcHkiLCJ0b3RhbF9wcm9qZWN0ZWRfYXB5Iiwicmlza1Njb3JlIiwicmlza19zY29yZSIsImdldFN0YXR1cyIsImluY2x1ZGVzIiwiYWdlbnRJZCIsImVudHJ5IiwidGFyZ2V0Iiwic3RvcCIsInJld2FyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/api.ts\n"));

/***/ })

});