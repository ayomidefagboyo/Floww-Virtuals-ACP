"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   agentsService: function() { return /* binding */ agentsService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\nconst API_BASE_URL = \"http://localhost:8002\" || 0;\n// Create axios instance with default config\nconst REQUEST_TIMEOUT = Number(process.env.NEXT_PUBLIC_API_TIMEOUT_MS || 90000);\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: REQUEST_TIMEOUT,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Response interceptor for error handling\napi.interceptors.response.use((response)=>response, (error)=>{\n    console.error(\"API Error:\", error);\n    return Promise.reject(error);\n});\nconst agentsService = {\n    // Get all available agents\n    async getAgents () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            // Transform backend agent data to frontend format\n            const agents = Object.entries(response.data.agents).map((param)=>{\n                let [key, agent] = param;\n                return {\n                    id: key,\n                    name: agent.name,\n                    description: agent.description,\n                    status: agent.status === \"online\" ? \"online\" : \"offline\",\n                    specialty: getSpecialtyFromCapabilities(agent.capabilities),\n                    actionLabel: getActionLabel(key),\n                    resultType: getResultType(key)\n                };\n            });\n            return agents;\n        } catch (error) {\n            console.error(\"Failed to fetch agents:\", error);\n            // Return default agents if API fails\n            return getDefaultAgents();\n        }\n    },\n    // Ryu Agent - Token Analysis\n    async analyzeToken (symbol) {\n        try {\n            var _data_entry_levels, _data_entry_levels1, _data_entry_levels2, _data_entry_levels3, _data_entry_levels4, _data_entry_levels5, _data_entry_levels6, _data_technical_analysis_rsi_14, _data_technical_analysis, _data_technical_analysis_macd_line, _data_technical_analysis1, _data_technical_analysis2, _data_scores, _data_scores1, _data_scores2, _data_scores3, _data_scores4;\n            console.log(\"\\uD83D\\uDD0D Requesting Ryu analysis for \".concat(symbol, \"...\"));\n            const response = await api.post(\"/api/agents/ryu/analyze\", {\n                symbol: symbol.toUpperCase(),\n                analysis_type: \"comprehensive\"\n            });\n            const data = response.data;\n            console.log(\"✅ Ryu analysis completed for \".concat(symbol));\n            return {\n                symbol: data.symbol,\n                action: data.recommendation || \"HOLD\",\n                confidence: data.confidence || 0.5,\n                currentPrice: data.current_price || 0,\n                entryRange: {\n                    min: ((_data_entry_levels = data.entry_levels) === null || _data_entry_levels === void 0 ? void 0 : _data_entry_levels.entry_range_low) || 0,\n                    max: ((_data_entry_levels1 = data.entry_levels) === null || _data_entry_levels1 === void 0 ? void 0 : _data_entry_levels1.entry_range_high) || 0\n                },\n                targets: {\n                    target1: ((_data_entry_levels2 = data.entry_levels) === null || _data_entry_levels2 === void 0 ? void 0 : _data_entry_levels2.target_1) || 0,\n                    target2: (_data_entry_levels3 = data.entry_levels) === null || _data_entry_levels3 === void 0 ? void 0 : _data_entry_levels3.target_2,\n                    target3: undefined\n                },\n                stopLoss: ((_data_entry_levels4 = data.entry_levels) === null || _data_entry_levels4 === void 0 ? void 0 : _data_entry_levels4.stop_loss) || 0,\n                riskRewardRatio: calculateRiskReward(data.current_price, (_data_entry_levels5 = data.entry_levels) === null || _data_entry_levels5 === void 0 ? void 0 : _data_entry_levels5.target_1, (_data_entry_levels6 = data.entry_levels) === null || _data_entry_levels6 === void 0 ? void 0 : _data_entry_levels6.stop_loss, data.recommendation),\n                analysis: {\n                    technical: \"RSI: \".concat(((_data_technical_analysis = data.technical_analysis) === null || _data_technical_analysis === void 0 ? void 0 : (_data_technical_analysis_rsi_14 = _data_technical_analysis.rsi_14) === null || _data_technical_analysis_rsi_14 === void 0 ? void 0 : _data_technical_analysis_rsi_14.toFixed(1)) || \"N/A\", \", MACD: \").concat(((_data_technical_analysis1 = data.technical_analysis) === null || _data_technical_analysis1 === void 0 ? void 0 : (_data_technical_analysis_macd_line = _data_technical_analysis1.macd_line) === null || _data_technical_analysis_macd_line === void 0 ? void 0 : _data_technical_analysis_macd_line.toFixed(4)) || \"N/A\", \", Trend: \").concat(((_data_technical_analysis2 = data.technical_analysis) === null || _data_technical_analysis2 === void 0 ? void 0 : _data_technical_analysis2.trend) || \"Unknown\"),\n                    fundamental: \"Market cap analysis and volume assessment completed\",\n                    sentiment: \"Market sentiment: \".concat(data.risk_assessment || \"Neutral\"),\n                    risk: \"Risk Level: \".concat(data.risk_assessment || \"Medium\")\n                },\n                scores: {\n                    technical: ((_data_scores = data.scores) === null || _data_scores === void 0 ? void 0 : _data_scores.technical) || 75,\n                    fundamental: ((_data_scores1 = data.scores) === null || _data_scores1 === void 0 ? void 0 : _data_scores1.overall) * 0.8 || 70,\n                    momentum: ((_data_scores2 = data.scores) === null || _data_scores2 === void 0 ? void 0 : _data_scores2.momentum) || 65,\n                    sentiment: ((_data_scores3 = data.scores) === null || _data_scores3 === void 0 ? void 0 : _data_scores3.volume) * 0.7 || 60,\n                    overall: ((_data_scores4 = data.scores) === null || _data_scores4 === void 0 ? void 0 : _data_scores4.overall) || 68\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            var _error_response, _error_response_data, _error_response1, _error_response_data1, _error_response2;\n            console.error(\"Token analysis failed:\", error);\n            // Handle specific API errors more gracefully\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail)) {\n                // Extract the meaningful error message from 404 responses\n                throw new Error(error.response.data.detail);\n            } else if ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data1 = _error_response2.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.detail) {\n                // Handle other API errors with detail messages\n                throw new Error(error.response.data.detail);\n            } else {\n                // Fallback for network or other errors\n                throw new Error(\"Failed to analyze \".concat(symbol, \": \").concat(error instanceof Error ? error.message : \"Network Error\"));\n            }\n        }\n    },\n    // Yuki Agent - Trade Scanner\n    async scanTrades () {\n        try {\n            console.log(\"⚡ Requesting Yuki trade scan...\");\n            const response = await api.post(\"/api/agents/yuki/scan\", {\n                scan_type: \"opportunities\",\n                pairs_limit: 500\n            });\n            const data = response.data;\n            console.log(\"✅ Yuki scan completed: \".concat(data.opportunities_found, \" opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        symbol: opp.symbol,\n                        direction: opp.direction,\n                        confidence: opp.confidence,\n                        entryPrice: opp.entry_price,\n                        target1: opp.target_1,\n                        target2: opp.target_2,\n                        stopLoss: opp.stop_loss,\n                        riskRewardRatio: opp.risk_reward_ratio,\n                        timeHorizon: opp.time_horizon,\n                        reasoning: opp.reasoning,\n                        keyFactors: opp.key_factors || [],\n                        expiresAt: opp.expires_at\n                    })),\n                totalScanned: data.total_scanned || 500,\n                bestOpportunity: data.opportunities[0] || null,\n                marketCondition: data.market_condition || \"Analyzed\",\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Trade scanning failed:\", error);\n            throw new Error(\"Failed to scan trades: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Yuki Agent - Progressive streaming scan (SSE)\n    streamTrades (onEvent) {\n        const url = \"\".concat(API_BASE_URL, \"/api/agents/yuki/scan/stream\");\n        const es = new EventSource(url);\n        const safeParse = (raw)=>{\n            try {\n                if (typeof raw === \"string\") return JSON.parse(raw);\n                return raw;\n            } catch (e) {\n                return raw;\n            }\n        };\n        es.addEventListener(\"progress\", (e)=>onEvent({\n                type: \"progress\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"opportunity\", (e)=>onEvent({\n                type: \"opportunity\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"complete\", (e)=>onEvent({\n                type: \"complete\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"error\", (e)=>onEvent({\n                type: \"error\",\n                data: safeParse(e.data || \"stream error\")\n            }));\n        // Return unsubscribe function\n        return ()=>es.close();\n    },\n    // Sakura Agent - Yield Opportunities\n    async getYieldOpportunities () {\n        try {\n            var _data_portfolio_recommendation_allocation, _data_portfolio_recommendation, _data_portfolio_recommendation1, _data_portfolio_recommendation2;\n            console.log(\"\\uD83C\\uDF38 Requesting Sakura yield analysis...\");\n            const response = await api.post(\"/api/agents/sakura/yield\", {\n                analysis_type: \"yield_farming\",\n                risk_preference: \"conservative\"\n            });\n            const data = response.data;\n            console.log(\"✅ Sakura analysis completed: \".concat(data.opportunities.length, \" yield opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        protocol: opp.protocol,\n                        asset: opp.asset,\n                        apy: opp.apy,\n                        tvl: opp.tvl,\n                        riskLevel: opp.risk_level,\n                        maturity: opp.maturity,\n                        minimumDeposit: opp.minimum_deposit,\n                        strategy: opp.strategy,\n                        projectedReturns: opp.projected_returns\n                    })),\n                totalTvlAnalyzed: data.total_tvl_analyzed || 0,\n                bestOpportunity: data.opportunities[0] || null,\n                portfolioRecommendation: {\n                    allocation: ((_data_portfolio_recommendation = data.portfolio_recommendation) === null || _data_portfolio_recommendation === void 0 ? void 0 : (_data_portfolio_recommendation_allocation = _data_portfolio_recommendation.allocation) === null || _data_portfolio_recommendation_allocation === void 0 ? void 0 : _data_portfolio_recommendation_allocation.map((alloc)=>({\n                            opportunity: {\n                                id: alloc.protocol.toLowerCase(),\n                                protocol: alloc.protocol,\n                                asset: \"Multi\",\n                                apy: alloc.apy_contribution * (100 / alloc.percentage),\n                                tvl: 0,\n                                riskLevel: \"LOW\",\n                                minimumDeposit: 100,\n                                strategy: \"Portfolio Allocation\",\n                                projectedReturns: {\n                                    monthly: alloc.apy_contribution / 12,\n                                    quarterly: alloc.apy_contribution / 4,\n                                    yearly: alloc.apy_contribution\n                                }\n                            },\n                            percentage: alloc.percentage\n                        }))) || [],\n                    totalProjectedApy: ((_data_portfolio_recommendation1 = data.portfolio_recommendation) === null || _data_portfolio_recommendation1 === void 0 ? void 0 : _data_portfolio_recommendation1.total_projected_apy) || 0,\n                    riskScore: ((_data_portfolio_recommendation2 = data.portfolio_recommendation) === null || _data_portfolio_recommendation2 === void 0 ? void 0 : _data_portfolio_recommendation2.risk_score) || 0.25\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Yield analysis failed:\", error);\n            throw new Error(\"Failed to get yield opportunities: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Get integration status\n    async getStatus () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to get status:\", error);\n            return null;\n        }\n    }\n};\n// Helper functions\nfunction getSpecialtyFromCapabilities(capabilities) {\n    if (capabilities.includes(\"token_analysis\")) return \"Token Analysis\";\n    if (capabilities.includes(\"market_scanning\")) return \"Trade Scanner\";\n    if (capabilities.includes(\"yield_optimization\")) return \"Yield Farming\";\n    return \"AI Analysis\";\n}\nfunction getActionLabel(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"Analyze Token\";\n        case \"yuki\":\n            return \"Find Trades\";\n        case \"sakura\":\n            return \"Get Yield Opportunities\";\n        default:\n            return \"Execute\";\n    }\n}\nfunction getResultType(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"AI Token Analysis Report\";\n        case \"yuki\":\n            return \"Market Opportunities\";\n        case \"sakura\":\n            return \"DeFi Yield Options\";\n        default:\n            return \"Analysis Results\";\n    }\n}\nfunction getDefaultAgents() {\n    return [\n        {\n            id: \"ryu\",\n            name: \"Ryu Agent\",\n            description: \"Professional token analysis with comprehensive AI scoring and risk assessment.\",\n            status: \"online\",\n            specialty: \"Token Analysis\",\n            actionLabel: \"Analyze Token\",\n            resultType: \"AI Token Analysis Report\"\n        },\n        {\n            id: \"yuki\",\n            name: \"Yuki Agent\",\n            description: \"Advanced trade scanner for high-frequency opportunities across 500+ trading pairs.\",\n            status: \"online\",\n            specialty: \"Trade Scanner\",\n            actionLabel: \"Find Trades\",\n            resultType: \"Market Opportunities\"\n        },\n        {\n            id: \"sakura\",\n            name: \"Sakura Agent\",\n            description: \"Conservative DeFi yield farming with Pendle integration and risk-adjusted returns.\",\n            status: \"online\",\n            specialty: \"Yield Farming\",\n            actionLabel: \"Get Yield Opportunities\",\n            resultType: \"DeFi Yield Options\"\n        }\n    ];\n}\nfunction calculateRiskReward(entry, target, stop, direction) {\n    try {\n        if (!entry || !target || !stop) return 0;\n        let reward;\n        let risk;\n        if (direction === \"LONG\") {\n            reward = target - entry;\n            risk = entry - stop;\n        } else {\n            reward = entry - target;\n            risk = stop - entry;\n        }\n        if (risk <= 0) return 0;\n        return reward / risk;\n    } catch (e) {\n        return 0;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDTixLQUFLO1lBQU8sT0FBTztRQUNuQixLQUFLO1lBQVEsT0FBTztRQUNwQixLQUFLO1lBQVUsT0FBTztRQUN0QjtZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUVBLFNBQVN2SDtJQUNQLE9BQU87UUFDTDtZQUNFWCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7UUFDQTtZQUNFVCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7UUFDQTtZQUNFVCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEcsYUFBYTtZQUNiRSxZQUFZO1FBQ2Q7S0FDRDtBQUNIO0FBRUEsU0FBUzhCLG9CQUFvQjRGLEtBQWEsRUFBRUMsTUFBYyxFQUFFQyxJQUFZLEVBQUVsRSxTQUFpQjtJQUN6RixJQUFJO1FBQ0YsSUFBSSxDQUFDZ0UsU0FBUyxDQUFDQyxVQUFVLENBQUNDLE1BQU0sT0FBTztRQUV2QyxJQUFJQztRQUNKLElBQUlwRjtRQUVKLElBQUlpQixjQUFjLFFBQVE7WUFDeEJtRSxTQUFTRixTQUFTRDtZQUNsQmpGLE9BQU9pRixRQUFRRTtRQUNqQixPQUFPO1lBQ0xDLFNBQVNILFFBQVFDO1lBQ2pCbEYsT0FBT21GLE9BQU9GO1FBQ2hCO1FBRUEsSUFBSWpGLFFBQVEsR0FBRyxPQUFPO1FBQ3RCLE9BQU9vRixTQUFTcEY7SUFDbEIsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFQSwrREFBZXhFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2FwaS50cz85NTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBBZ2VudCwgVG9rZW5BbmFseXNpc1Jlc3VsdCwgVHJhZGVTY2FuUmVzdWx0LCBZaWVsZEFuYWx5c2lzUmVzdWx0IH0gZnJvbSAnQC90eXBlcy9hZ2VudHMnO1xuXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDEnO1xuXG4vLyBDcmVhdGUgYXhpb3MgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IGNvbmZpZ1xuY29uc3QgUkVRVUVTVF9USU1FT1VUID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9USU1FT1VUX01TIHx8IDkwMDAwKTtcblxuY29uc3QgYXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxuICB0aW1lb3V0OiBSRVFVRVNUX1RJTUVPVVQsIC8vIGNvbmZpZ3VyYWJsZSBmb3IgbG9uZy1ydW5uaW5nIHNjYW5zXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9LFxufSk7XG5cbi8vIFJlc3BvbnNlIGludGVyY2VwdG9yIGZvciBlcnJvciBoYW5kbGluZ1xuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXG4gIChlcnJvcikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuZXhwb3J0IGNvbnN0IGFnZW50c1NlcnZpY2UgPSB7XG4gIC8vIEdldCBhbGwgYXZhaWxhYmxlIGFnZW50c1xuICBhc3luYyBnZXRBZ2VudHMoKTogUHJvbWlzZTxBZ2VudFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2FwaS9hZ2VudHMvc3RhdHVzJyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIGFnZW50IGRhdGEgdG8gZnJvbnRlbmQgZm9ybWF0XG4gICAgICBjb25zdCBhZ2VudHM6IEFnZW50W10gPSBPYmplY3QuZW50cmllcyhyZXNwb25zZS5kYXRhLmFnZW50cykubWFwKChba2V5LCBhZ2VudF06IFtzdHJpbmcsIGFueV0pID0+ICh7XG4gICAgICAgIGlkOiBrZXksXG4gICAgICAgIG5hbWU6IGFnZW50Lm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBhZ2VudC5kZXNjcmlwdGlvbixcbiAgICAgICAgc3RhdHVzOiBhZ2VudC5zdGF0dXMgPT09ICdvbmxpbmUnID8gJ29ubGluZScgYXMgY29uc3QgOiAnb2ZmbGluZScgYXMgY29uc3QsXG4gICAgICAgIHNwZWNpYWx0eTogZ2V0U3BlY2lhbHR5RnJvbUNhcGFiaWxpdGllcyhhZ2VudC5jYXBhYmlsaXRpZXMpLFxuICAgICAgICBhY3Rpb25MYWJlbDogZ2V0QWN0aW9uTGFiZWwoa2V5KSxcbiAgICAgICAgcmVzdWx0VHlwZTogZ2V0UmVzdWx0VHlwZShrZXkpLFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gYWdlbnRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWdlbnRzOicsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IGFnZW50cyBpZiBBUEkgZmFpbHNcbiAgICAgIHJldHVybiBnZXREZWZhdWx0QWdlbnRzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJ5dSBBZ2VudCAtIFRva2VuIEFuYWx5c2lzXG4gIGFzeW5jIGFuYWx5emVUb2tlbihzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8VG9rZW5BbmFseXNpc1Jlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBSZXF1ZXN0aW5nIFJ5dSBhbmFseXNpcyBmb3IgJHtzeW1ib2x9Li4uYCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3J5dS9hbmFseXplJywge1xuICAgICAgICBzeW1ib2w6IHN5bWJvbC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBhbmFseXNpc190eXBlOiAnY29tcHJlaGVuc2l2ZSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBSeXUgYW5hbHlzaXMgY29tcGxldGVkIGZvciAke3N5bWJvbH1gKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sOiBkYXRhLnN5bWJvbCxcbiAgICAgICAgYWN0aW9uOiBkYXRhLnJlY29tbWVuZGF0aW9uIHx8ICdIT0xEJyxcbiAgICAgICAgY29uZmlkZW5jZTogZGF0YS5jb25maWRlbmNlIHx8IDAuNSxcbiAgICAgICAgY3VycmVudFByaWNlOiBkYXRhLmN1cnJlbnRfcHJpY2UgfHwgMCxcbiAgICAgICAgZW50cnlSYW5nZToge1xuICAgICAgICAgIG1pbjogZGF0YS5lbnRyeV9sZXZlbHM/LmVudHJ5X3JhbmdlX2xvdyB8fCAwLFxuICAgICAgICAgIG1heDogZGF0YS5lbnRyeV9sZXZlbHM/LmVudHJ5X3JhbmdlX2hpZ2ggfHwgMCxcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0czoge1xuICAgICAgICAgIHRhcmdldDE6IGRhdGEuZW50cnlfbGV2ZWxzPy50YXJnZXRfMSB8fCAwLFxuICAgICAgICAgIHRhcmdldDI6IGRhdGEuZW50cnlfbGV2ZWxzPy50YXJnZXRfMixcbiAgICAgICAgICB0YXJnZXQzOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BMb3NzOiBkYXRhLmVudHJ5X2xldmVscz8uc3RvcF9sb3NzIHx8IDAsXG4gICAgICAgIHJpc2tSZXdhcmRSYXRpbzogY2FsY3VsYXRlUmlza1Jld2FyZChcbiAgICAgICAgICBkYXRhLmN1cnJlbnRfcHJpY2UsXG4gICAgICAgICAgZGF0YS5lbnRyeV9sZXZlbHM/LnRhcmdldF8xLFxuICAgICAgICAgIGRhdGEuZW50cnlfbGV2ZWxzPy5zdG9wX2xvc3MsXG4gICAgICAgICAgZGF0YS5yZWNvbW1lbmRhdGlvblxuICAgICAgICApLFxuICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgIHRlY2huaWNhbDogYFJTSTogJHtkYXRhLnRlY2huaWNhbF9hbmFseXNpcz8ucnNpXzE0Py50b0ZpeGVkKDEpIHx8ICdOL0EnfSwgTUFDRDogJHtkYXRhLnRlY2huaWNhbF9hbmFseXNpcz8ubWFjZF9saW5lPy50b0ZpeGVkKDQpIHx8ICdOL0EnfSwgVHJlbmQ6ICR7ZGF0YS50ZWNobmljYWxfYW5hbHlzaXM/LnRyZW5kIHx8ICdVbmtub3duJ31gLFxuICAgICAgICAgIGZ1bmRhbWVudGFsOiBgTWFya2V0IGNhcCBhbmFseXNpcyBhbmQgdm9sdW1lIGFzc2Vzc21lbnQgY29tcGxldGVkYCxcbiAgICAgICAgICBzZW50aW1lbnQ6IGBNYXJrZXQgc2VudGltZW50OiAke2RhdGEucmlza19hc3Nlc3NtZW50IHx8ICdOZXV0cmFsJ31gLFxuICAgICAgICAgIHJpc2s6IGBSaXNrIExldmVsOiAke2RhdGEucmlza19hc3Nlc3NtZW50IHx8ICdNZWRpdW0nfWAsXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3Jlczoge1xuICAgICAgICAgIHRlY2huaWNhbDogZGF0YS5zY29yZXM/LnRlY2huaWNhbCB8fCA3NSxcbiAgICAgICAgICBmdW5kYW1lbnRhbDogZGF0YS5zY29yZXM/Lm92ZXJhbGwgKiAwLjggfHwgNzAsXG4gICAgICAgICAgbW9tZW50dW06IGRhdGEuc2NvcmVzPy5tb21lbnR1bSB8fCA2NSxcbiAgICAgICAgICBzZW50aW1lbnQ6IGRhdGEuc2NvcmVzPy52b2x1bWUgKiAwLjcgfHwgNjAsXG4gICAgICAgICAgb3ZlcmFsbDogZGF0YS5zY29yZXM/Lm92ZXJhbGwgfHwgNjgsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBhbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xuXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgQVBJIGVycm9ycyBtb3JlIGdyYWNlZnVsbHlcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDQgJiYgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbCkge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UgZnJvbSA0MDQgcmVzcG9uc2VzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCk7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWwpIHtcbiAgICAgICAgLy8gSGFuZGxlIG90aGVyIEFQSSBlcnJvcnMgd2l0aCBkZXRhaWwgbWVzc2FnZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBuZXR3b3JrIG9yIG90aGVyIGVycm9yc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhbmFseXplICR7c3ltYm9sfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdOZXR3b3JrIEVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gWXVraSBBZ2VudCAtIFRyYWRlIFNjYW5uZXJcbiAgYXN5bmMgc2NhblRyYWRlcygpOiBQcm9taXNlPFRyYWRlU2NhblJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqhIFJlcXVlc3RpbmcgWXVraSB0cmFkZSBzY2FuLi4uJyk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3l1a2kvc2NhbicsIHtcbiAgICAgICAgc2Nhbl90eXBlOiAnb3Bwb3J0dW5pdGllcycsXG4gICAgICAgIHBhaXJzX2xpbWl0OiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBZdWtpIHNjYW4gY29tcGxldGVkOiAke2RhdGEub3Bwb3J0dW5pdGllc19mb3VuZH0gb3Bwb3J0dW5pdGllcyBmb3VuZGApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcHBvcnR1bml0aWVzOiBkYXRhLm9wcG9ydHVuaXRpZXMubWFwKChvcHA6IGFueSkgPT4gKHtcbiAgICAgICAgICBpZDogb3BwLmlkLFxuICAgICAgICAgIHN5bWJvbDogb3BwLnN5bWJvbCxcbiAgICAgICAgICBkaXJlY3Rpb246IG9wcC5kaXJlY3Rpb24sXG4gICAgICAgICAgY29uZmlkZW5jZTogb3BwLmNvbmZpZGVuY2UsXG4gICAgICAgICAgZW50cnlQcmljZTogb3BwLmVudHJ5X3ByaWNlLFxuICAgICAgICAgIHRhcmdldDE6IG9wcC50YXJnZXRfMSxcbiAgICAgICAgICB0YXJnZXQyOiBvcHAudGFyZ2V0XzIsXG4gICAgICAgICAgc3RvcExvc3M6IG9wcC5zdG9wX2xvc3MsXG4gICAgICAgICAgcmlza1Jld2FyZFJhdGlvOiBvcHAucmlza19yZXdhcmRfcmF0aW8sXG4gICAgICAgICAgdGltZUhvcml6b246IG9wcC50aW1lX2hvcml6b24sXG4gICAgICAgICAgcmVhc29uaW5nOiBvcHAucmVhc29uaW5nLFxuICAgICAgICAgIGtleUZhY3RvcnM6IG9wcC5rZXlfZmFjdG9ycyB8fCBbXSxcbiAgICAgICAgICBleHBpcmVzQXQ6IG9wcC5leHBpcmVzX2F0LFxuICAgICAgICB9KSksXG4gICAgICAgIHRvdGFsU2Nhbm5lZDogZGF0YS50b3RhbF9zY2FubmVkIHx8IDUwMCxcbiAgICAgICAgYmVzdE9wcG9ydHVuaXR5OiBkYXRhLm9wcG9ydHVuaXRpZXNbMF0gfHwgbnVsbCxcbiAgICAgICAgbWFya2V0Q29uZGl0aW9uOiBkYXRhLm1hcmtldF9jb25kaXRpb24gfHwgJ0FuYWx5emVkJyxcbiAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUcmFkZSBzY2FubmluZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2NhbiB0cmFkZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFl1a2kgQWdlbnQgLSBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgc2NhbiAoU1NFKVxuICBzdHJlYW1UcmFkZXMob25FdmVudDogKGV2dDogeyB0eXBlOiAncHJvZ3Jlc3MnIHwgJ29wcG9ydHVuaXR5JyB8ICdjb21wbGV0ZScgfCAnZXJyb3InOyBkYXRhOiBhbnkgfSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0vYXBpL2FnZW50cy95dWtpL3NjYW4vc3RyZWFtYDtcbiAgICBjb25zdCBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmwpO1xuXG4gICAgY29uc3Qgc2FmZVBhcnNlID0gKHJhdzogYW55KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZTogTWVzc2FnZUV2ZW50KSA9PiBvbkV2ZW50KHsgdHlwZTogJ3Byb2dyZXNzJywgZGF0YTogc2FmZVBhcnNlKGUuZGF0YSkgfSkpO1xuICAgIGVzLmFkZEV2ZW50TGlzdGVuZXIoJ29wcG9ydHVuaXR5JywgKGU6IE1lc3NhZ2VFdmVudCkgPT4gb25FdmVudCh7IHR5cGU6ICdvcHBvcnR1bml0eScsIGRhdGE6IHNhZmVQYXJzZShlLmRhdGEpIH0pKTtcbiAgICBlcy5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIChlOiBNZXNzYWdlRXZlbnQpID0+IG9uRXZlbnQoeyB0eXBlOiAnY29tcGxldGUnLCBkYXRhOiBzYWZlUGFyc2UoZS5kYXRhKSB9KSk7XG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZTogTWVzc2FnZUV2ZW50KSA9PiBvbkV2ZW50KHsgdHlwZTogJ2Vycm9yJywgZGF0YTogc2FmZVBhcnNlKChlIGFzIGFueSkuZGF0YSB8fCAnc3RyZWFtIGVycm9yJykgfSkpO1xuXG4gICAgLy8gUmV0dXJuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IGVzLmNsb3NlKCk7XG4gIH0sXG5cbiAgLy8gU2FrdXJhIEFnZW50IC0gWWllbGQgT3Bwb3J0dW5pdGllc1xuICBhc3luYyBnZXRZaWVsZE9wcG9ydHVuaXRpZXMoKTogUHJvbWlzZTxZaWVsZEFuYWx5c2lzUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4y4IFJlcXVlc3RpbmcgU2FrdXJhIHlpZWxkIGFuYWx5c2lzLi4uJyk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3Nha3VyYS95aWVsZCcsIHtcbiAgICAgICAgYW5hbHlzaXNfdHlwZTogJ3lpZWxkX2Zhcm1pbmcnLFxuICAgICAgICByaXNrX3ByZWZlcmVuY2U6ICdjb25zZXJ2YXRpdmUnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU2FrdXJhIGFuYWx5c2lzIGNvbXBsZXRlZDogJHtkYXRhLm9wcG9ydHVuaXRpZXMubGVuZ3RofSB5aWVsZCBvcHBvcnR1bml0aWVzIGZvdW5kYCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wcG9ydHVuaXRpZXM6IGRhdGEub3Bwb3J0dW5pdGllcy5tYXAoKG9wcDogYW55KSA9PiAoe1xuICAgICAgICAgIGlkOiBvcHAuaWQsXG4gICAgICAgICAgcHJvdG9jb2w6IG9wcC5wcm90b2NvbCxcbiAgICAgICAgICBhc3NldDogb3BwLmFzc2V0LFxuICAgICAgICAgIGFweTogb3BwLmFweSxcbiAgICAgICAgICB0dmw6IG9wcC50dmwsXG4gICAgICAgICAgcmlza0xldmVsOiBvcHAucmlza19sZXZlbCxcbiAgICAgICAgICBtYXR1cml0eTogb3BwLm1hdHVyaXR5LFxuICAgICAgICAgIG1pbmltdW1EZXBvc2l0OiBvcHAubWluaW11bV9kZXBvc2l0LFxuICAgICAgICAgIHN0cmF0ZWd5OiBvcHAuc3RyYXRlZ3ksXG4gICAgICAgICAgcHJvamVjdGVkUmV0dXJuczogb3BwLnByb2plY3RlZF9yZXR1cm5zLFxuICAgICAgICB9KSksXG4gICAgICAgIHRvdGFsVHZsQW5hbHl6ZWQ6IGRhdGEudG90YWxfdHZsX2FuYWx5emVkIHx8IDAsXG4gICAgICAgIGJlc3RPcHBvcnR1bml0eTogZGF0YS5vcHBvcnR1bml0aWVzWzBdIHx8IG51bGwsXG4gICAgICAgIHBvcnRmb2xpb1JlY29tbWVuZGF0aW9uOiB7XG4gICAgICAgICAgYWxsb2NhdGlvbjogZGF0YS5wb3J0Zm9saW9fcmVjb21tZW5kYXRpb24/LmFsbG9jYXRpb24/Lm1hcCgoYWxsb2M6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIG9wcG9ydHVuaXR5OiB7XG4gICAgICAgICAgICAgIGlkOiBhbGxvYy5wcm90b2NvbC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBwcm90b2NvbDogYWxsb2MucHJvdG9jb2wsXG4gICAgICAgICAgICAgIGFzc2V0OiAnTXVsdGknLFxuICAgICAgICAgICAgICBhcHk6IGFsbG9jLmFweV9jb250cmlidXRpb24gKiAoMTAwIC8gYWxsb2MucGVyY2VudGFnZSksXG4gICAgICAgICAgICAgIHR2bDogMCxcbiAgICAgICAgICAgICAgcmlza0xldmVsOiAnTE9XJyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgbWluaW11bURlcG9zaXQ6IDEwMCxcbiAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdQb3J0Zm9saW8gQWxsb2NhdGlvbicsXG4gICAgICAgICAgICAgIHByb2plY3RlZFJldHVybnM6IHtcbiAgICAgICAgICAgICAgICBtb250aGx5OiBhbGxvYy5hcHlfY29udHJpYnV0aW9uIC8gMTIsXG4gICAgICAgICAgICAgICAgcXVhcnRlcmx5OiBhbGxvYy5hcHlfY29udHJpYnV0aW9uIC8gNCxcbiAgICAgICAgICAgICAgICB5ZWFybHk6IGFsbG9jLmFweV9jb250cmlidXRpb24sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGVyY2VudGFnZTogYWxsb2MucGVyY2VudGFnZSxcbiAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgdG90YWxQcm9qZWN0ZWRBcHk6IGRhdGEucG9ydGZvbGlvX3JlY29tbWVuZGF0aW9uPy50b3RhbF9wcm9qZWN0ZWRfYXB5IHx8IDAsXG4gICAgICAgICAgcmlza1Njb3JlOiBkYXRhLnBvcnRmb2xpb19yZWNvbW1lbmRhdGlvbj8ucmlza19zY29yZSB8fCAwLjI1LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1lpZWxkIGFuYWx5c2lzIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgeWllbGQgb3Bwb3J0dW5pdGllczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gR2V0IGludGVncmF0aW9uIHN0YXR1c1xuICBhc3luYyBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2FwaS9hZ2VudHMvc3RhdHVzJyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0U3BlY2lhbHR5RnJvbUNhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKGNhcGFiaWxpdGllcy5pbmNsdWRlcygndG9rZW5fYW5hbHlzaXMnKSkgcmV0dXJuICdUb2tlbiBBbmFseXNpcyc7XG4gIGlmIChjYXBhYmlsaXRpZXMuaW5jbHVkZXMoJ21hcmtldF9zY2FubmluZycpKSByZXR1cm4gJ1RyYWRlIFNjYW5uZXInO1xuICBpZiAoY2FwYWJpbGl0aWVzLmluY2x1ZGVzKCd5aWVsZF9vcHRpbWl6YXRpb24nKSkgcmV0dXJuICdZaWVsZCBGYXJtaW5nJztcbiAgcmV0dXJuICdBSSBBbmFseXNpcyc7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbkxhYmVsKGFnZW50SWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWdlbnRJZCkge1xuICAgIGNhc2UgJ3J5dSc6IHJldHVybiAnQW5hbHl6ZSBUb2tlbic7XG4gICAgY2FzZSAneXVraSc6IHJldHVybiAnRmluZCBUcmFkZXMnO1xuICAgIGNhc2UgJ3Nha3VyYSc6IHJldHVybiAnR2V0IFlpZWxkIE9wcG9ydHVuaXRpZXMnO1xuICAgIGRlZmF1bHQ6IHJldHVybiAnRXhlY3V0ZSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzdWx0VHlwZShhZ2VudElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGFnZW50SWQpIHtcbiAgICBjYXNlICdyeXUnOiByZXR1cm4gJ0FJIFRva2VuIEFuYWx5c2lzIFJlcG9ydCc7XG4gICAgY2FzZSAneXVraSc6IHJldHVybiAnTWFya2V0IE9wcG9ydHVuaXRpZXMnO1xuICAgIGNhc2UgJ3Nha3VyYSc6IHJldHVybiAnRGVGaSBZaWVsZCBPcHRpb25zJztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ0FuYWx5c2lzIFJlc3VsdHMnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZ2VudHMoKTogQWdlbnRbXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6ICdyeXUnLFxuICAgICAgbmFtZTogJ1J5dSBBZ2VudCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb2Zlc3Npb25hbCB0b2tlbiBhbmFseXNpcyB3aXRoIGNvbXByZWhlbnNpdmUgQUkgc2NvcmluZyBhbmQgcmlzayBhc3Nlc3NtZW50LicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnVG9rZW4gQW5hbHlzaXMnLFxuICAgICAgYWN0aW9uTGFiZWw6ICdBbmFseXplIFRva2VuJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdBSSBUb2tlbiBBbmFseXNpcyBSZXBvcnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICd5dWtpJyxcbiAgICAgIG5hbWU6ICdZdWtpIEFnZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWR2YW5jZWQgdHJhZGUgc2Nhbm5lciBmb3IgaGlnaC1mcmVxdWVuY3kgb3Bwb3J0dW5pdGllcyBhY3Jvc3MgNTAwKyB0cmFkaW5nIHBhaXJzLicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnVHJhZGUgU2Nhbm5lcicsXG4gICAgICBhY3Rpb25MYWJlbDogJ0ZpbmQgVHJhZGVzJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdNYXJrZXQgT3Bwb3J0dW5pdGllcycsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3Nha3VyYScsXG4gICAgICBuYW1lOiAnU2FrdXJhIEFnZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29uc2VydmF0aXZlIERlRmkgeWllbGQgZmFybWluZyB3aXRoIFBlbmRsZSBpbnRlZ3JhdGlvbiBhbmQgcmlzay1hZGp1c3RlZCByZXR1cm5zLicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnWWllbGQgRmFybWluZycsXG4gICAgICBhY3Rpb25MYWJlbDogJ0dldCBZaWVsZCBPcHBvcnR1bml0aWVzJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdEZUZpIFlpZWxkIE9wdGlvbnMnLFxuICAgIH0sXG4gIF07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpc2tSZXdhcmQoZW50cnk6IG51bWJlciwgdGFyZ2V0OiBudW1iZXIsIHN0b3A6IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICB0cnkge1xuICAgIGlmICghZW50cnkgfHwgIXRhcmdldCB8fCAhc3RvcCkgcmV0dXJuIDA7XG5cbiAgICBsZXQgcmV3YXJkOiBudW1iZXI7XG4gICAgbGV0IHJpc2s6IG51bWJlcjtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdMT05HJykge1xuICAgICAgcmV3YXJkID0gdGFyZ2V0IC0gZW50cnk7XG4gICAgICByaXNrID0gZW50cnkgLSBzdG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXdhcmQgPSBlbnRyeSAtIHRhcmdldDtcbiAgICAgIHJpc2sgPSBzdG9wIC0gZW50cnk7XG4gICAgfVxuXG4gICAgaWYgKHJpc2sgPD0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHJld2FyZCAvIHJpc2s7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFwaTsiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIlJFUVVFU1RfVElNRU9VVCIsIk51bWJlciIsIk5FWFRfUFVCTElDX0FQSV9USU1FT1VUX01TIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVzcG9uc2UiLCJ1c2UiLCJlcnJvciIsImNvbnNvbGUiLCJQcm9taXNlIiwicmVqZWN0IiwiYWdlbnRzU2VydmljZSIsImdldEFnZW50cyIsImdldCIsImFnZW50cyIsIk9iamVjdCIsImVudHJpZXMiLCJkYXRhIiwibWFwIiwia2V5IiwiYWdlbnQiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInN0YXR1cyIsInNwZWNpYWx0eSIsImdldFNwZWNpYWx0eUZyb21DYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXRpZXMiLCJhY3Rpb25MYWJlbCIsImdldEFjdGlvbkxhYmVsIiwicmVzdWx0VHlwZSIsImdldFJlc3VsdFR5cGUiLCJnZXREZWZhdWx0QWdlbnRzIiwiYW5hbHl6ZVRva2VuIiwic3ltYm9sIiwibG9nIiwicG9zdCIsInRvVXBwZXJDYXNlIiwiYW5hbHlzaXNfdHlwZSIsImFjdGlvbiIsInJlY29tbWVuZGF0aW9uIiwiY29uZmlkZW5jZSIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRfcHJpY2UiLCJlbnRyeVJhbmdlIiwibWluIiwiZW50cnlfbGV2ZWxzIiwiZW50cnlfcmFuZ2VfbG93IiwibWF4IiwiZW50cnlfcmFuZ2VfaGlnaCIsInRhcmdldHMiLCJ0YXJnZXQxIiwidGFyZ2V0XzEiLCJ0YXJnZXQyIiwidGFyZ2V0XzIiLCJ0YXJnZXQzIiwidW5kZWZpbmVkIiwic3RvcExvc3MiLCJzdG9wX2xvc3MiLCJyaXNrUmV3YXJkUmF0aW8iLCJjYWxjdWxhdGVSaXNrUmV3YXJkIiwiYW5hbHlzaXMiLCJ0ZWNobmljYWwiLCJ0ZWNobmljYWxfYW5hbHlzaXMiLCJyc2lfMTQiLCJ0b0ZpeGVkIiwibWFjZF9saW5lIiwidHJlbmQiLCJmdW5kYW1lbnRhbCIsInNlbnRpbWVudCIsInJpc2tfYXNzZXNzbWVudCIsInJpc2siLCJzY29yZXMiLCJvdmVyYWxsIiwibW9tZW50dW0iLCJ2b2x1bWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkZXRhaWwiLCJFcnJvciIsIm1lc3NhZ2UiLCJzY2FuVHJhZGVzIiwic2Nhbl90eXBlIiwicGFpcnNfbGltaXQiLCJvcHBvcnR1bml0aWVzX2ZvdW5kIiwib3Bwb3J0dW5pdGllcyIsIm9wcCIsImRpcmVjdGlvbiIsImVudHJ5UHJpY2UiLCJlbnRyeV9wcmljZSIsInJpc2tfcmV3YXJkX3JhdGlvIiwidGltZUhvcml6b24iLCJ0aW1lX2hvcml6b24iLCJyZWFzb25pbmciLCJrZXlGYWN0b3JzIiwia2V5X2ZhY3RvcnMiLCJleHBpcmVzQXQiLCJleHBpcmVzX2F0IiwidG90YWxTY2FubmVkIiwidG90YWxfc2Nhbm5lZCIsImJlc3RPcHBvcnR1bml0eSIsIm1hcmtldENvbmRpdGlvbiIsIm1hcmtldF9jb25kaXRpb24iLCJzdHJlYW1UcmFkZXMiLCJvbkV2ZW50IiwidXJsIiwiZXMiLCJFdmVudFNvdXJjZSIsInNhZmVQYXJzZSIsInJhdyIsIkpTT04iLCJwYXJzZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwidHlwZSIsImNsb3NlIiwiZ2V0WWllbGRPcHBvcnR1bml0aWVzIiwicmlza19wcmVmZXJlbmNlIiwibGVuZ3RoIiwicHJvdG9jb2wiLCJhc3NldCIsImFweSIsInR2bCIsInJpc2tMZXZlbCIsInJpc2tfbGV2ZWwiLCJtYXR1cml0eSIsIm1pbmltdW1EZXBvc2l0IiwibWluaW11bV9kZXBvc2l0Iiwic3RyYXRlZ3kiLCJwcm9qZWN0ZWRSZXR1cm5zIiwicHJvamVjdGVkX3JldHVybnMiLCJ0b3RhbFR2bEFuYWx5emVkIiwidG90YWxfdHZsX2FuYWx5emVkIiwicG9ydGZvbGlvUmVjb21tZW5kYXRpb24iLCJhbGxvY2F0aW9uIiwicG9ydGZvbGlvX3JlY29tbWVuZGF0aW9uIiwiYWxsb2MiLCJvcHBvcnR1bml0eSIsInRvTG93ZXJDYXNlIiwiYXB5X2NvbnRyaWJ1dGlvbiIsInBlcmNlbnRhZ2UiLCJtb250aGx5IiwicXVhcnRlcmx5IiwieWVhcmx5IiwidG90YWxQcm9qZWN0ZWRBcHkiLCJ0b3RhbF9wcm9qZWN0ZWRfYXB5Iiwicmlza1Njb3JlIiwicmlza19zY29yZSIsImdldFN0YXR1cyIsImluY2x1ZGVzIiwiYWdlbnRJZCIsImVudHJ5IiwidGFyZ2V0Iiwic3RvcCIsInJld2FyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/api.ts\n"));

/***/ })

});