"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   agentsService: function() { return /* binding */ agentsService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\nconst API_BASE_URL = \"http://localhost:8002\" || 0;\n// Create axios instance with default config\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    // Disable client-side timeout to allow long-running Yuki scans\n    timeout: 0,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Response interceptor for error handling\napi.interceptors.response.use((response)=>response, (error)=>{\n    console.error(\"API Error:\", error);\n    return Promise.reject(error);\n});\nconst agentsService = {\n    // Get all available agents\n    async getAgents () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            // Transform backend agent data to frontend format\n            const agents = Object.entries(response.data.agents).map((param)=>{\n                let [key, agent] = param;\n                return {\n                    id: key,\n                    name: agent.name,\n                    description: agent.description,\n                    status: agent.status === \"online\" ? \"online\" : \"offline\",\n                    specialty: getSpecialtyFromCapabilities(agent.capabilities),\n                    actionLabel: getActionLabel(key),\n                    resultType: getResultType(key)\n                };\n            });\n            return agents;\n        } catch (error) {\n            console.error(\"Failed to fetch agents:\", error);\n            // Return default agents if API fails\n            return getDefaultAgents();\n        }\n    },\n    // Ryu Agent - Token Analysis\n    async analyzeToken (symbol) {\n        try {\n            var _data_entry_levels, _data_entry_levels1, _data_entry_levels2, _data_entry_levels3, _data_entry_levels4, _data_entry_levels5, _data_entry_levels6, _data_technical_analysis_rsi_14, _data_technical_analysis, _data_technical_analysis_macd_line, _data_technical_analysis1, _data_technical_analysis2, _data_scores, _data_scores1, _data_scores2, _data_scores3, _data_scores4;\n            console.log(\"\\uD83D\\uDD0D Requesting Ryu analysis for \".concat(symbol, \"...\"));\n            const response = await api.post(\"/api/agents/ryu/analyze\", {\n                symbol: symbol.toUpperCase(),\n                analysis_type: \"comprehensive\"\n            });\n            const data = response.data;\n            console.log(\"✅ Ryu analysis completed for \".concat(symbol));\n            return {\n                symbol: data.symbol,\n                action: data.recommendation || \"HOLD\",\n                confidence: data.confidence || 0.5,\n                currentPrice: data.current_price || 0,\n                entryRange: {\n                    min: ((_data_entry_levels = data.entry_levels) === null || _data_entry_levels === void 0 ? void 0 : _data_entry_levels.entry_range_low) || 0,\n                    max: ((_data_entry_levels1 = data.entry_levels) === null || _data_entry_levels1 === void 0 ? void 0 : _data_entry_levels1.entry_range_high) || 0\n                },\n                targets: {\n                    target1: ((_data_entry_levels2 = data.entry_levels) === null || _data_entry_levels2 === void 0 ? void 0 : _data_entry_levels2.target_1) || 0,\n                    target2: (_data_entry_levels3 = data.entry_levels) === null || _data_entry_levels3 === void 0 ? void 0 : _data_entry_levels3.target_2,\n                    target3: undefined\n                },\n                stopLoss: ((_data_entry_levels4 = data.entry_levels) === null || _data_entry_levels4 === void 0 ? void 0 : _data_entry_levels4.stop_loss) || 0,\n                riskRewardRatio: calculateRiskReward(data.current_price, (_data_entry_levels5 = data.entry_levels) === null || _data_entry_levels5 === void 0 ? void 0 : _data_entry_levels5.target_1, (_data_entry_levels6 = data.entry_levels) === null || _data_entry_levels6 === void 0 ? void 0 : _data_entry_levels6.stop_loss, data.recommendation),\n                analysis: {\n                    technical: \"RSI: \".concat(((_data_technical_analysis = data.technical_analysis) === null || _data_technical_analysis === void 0 ? void 0 : (_data_technical_analysis_rsi_14 = _data_technical_analysis.rsi_14) === null || _data_technical_analysis_rsi_14 === void 0 ? void 0 : _data_technical_analysis_rsi_14.toFixed(1)) || \"N/A\", \", MACD: \").concat(((_data_technical_analysis1 = data.technical_analysis) === null || _data_technical_analysis1 === void 0 ? void 0 : (_data_technical_analysis_macd_line = _data_technical_analysis1.macd_line) === null || _data_technical_analysis_macd_line === void 0 ? void 0 : _data_technical_analysis_macd_line.toFixed(4)) || \"N/A\", \", Trend: \").concat(((_data_technical_analysis2 = data.technical_analysis) === null || _data_technical_analysis2 === void 0 ? void 0 : _data_technical_analysis2.trend) || \"Unknown\"),\n                    fundamental: \"Market cap analysis and volume assessment completed\",\n                    sentiment: \"Market sentiment: \".concat(data.risk_assessment || \"Neutral\"),\n                    risk: \"Risk Level: \".concat(data.risk_assessment || \"Medium\")\n                },\n                scores: {\n                    technical: ((_data_scores = data.scores) === null || _data_scores === void 0 ? void 0 : _data_scores.technical) || 75,\n                    fundamental: ((_data_scores1 = data.scores) === null || _data_scores1 === void 0 ? void 0 : _data_scores1.overall) * 0.8 || 70,\n                    momentum: ((_data_scores2 = data.scores) === null || _data_scores2 === void 0 ? void 0 : _data_scores2.momentum) || 65,\n                    sentiment: ((_data_scores3 = data.scores) === null || _data_scores3 === void 0 ? void 0 : _data_scores3.volume) * 0.7 || 60,\n                    overall: ((_data_scores4 = data.scores) === null || _data_scores4 === void 0 ? void 0 : _data_scores4.overall) || 68\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            var _error_response, _error_response_data, _error_response1, _error_response_data1, _error_response2;\n            console.error(\"Token analysis failed:\", error);\n            // Handle specific API errors more gracefully\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail)) {\n                // Extract the meaningful error message from 404 responses\n                throw new Error(error.response.data.detail);\n            } else if ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data1 = _error_response2.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.detail) {\n                // Handle other API errors with detail messages\n                throw new Error(error.response.data.detail);\n            } else {\n                // Fallback for network or other errors\n                throw new Error(\"Failed to analyze \".concat(symbol, \": \").concat(error instanceof Error ? error.message : \"Network Error\"));\n            }\n        }\n    },\n    // Yuki Agent - Trade Scanner\n    async scanTrades () {\n        try {\n            console.log(\"⚡ Requesting Yuki trade scan...\");\n            const response = await api.post(\"/api/agents/yuki/scan\", {\n                scan_type: \"opportunities\",\n                pairs_limit: 500\n            });\n            const data = response.data;\n            console.log(\"✅ Yuki scan completed: \".concat(data.opportunities_found, \" opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        symbol: opp.symbol,\n                        direction: opp.direction,\n                        confidence: opp.confidence,\n                        entryPrice: opp.entry_price,\n                        target1: opp.target_1,\n                        target2: opp.target_2,\n                        stopLoss: opp.stop_loss,\n                        riskRewardRatio: opp.risk_reward_ratio,\n                        timeHorizon: opp.time_horizon,\n                        reasoning: opp.reasoning,\n                        keyFactors: opp.key_factors || [],\n                        expiresAt: opp.expires_at\n                    })),\n                totalScanned: data.total_scanned || 500,\n                bestOpportunity: data.opportunities[0] || null,\n                marketCondition: data.market_condition || \"Analyzed\",\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Trade scanning failed:\", error);\n            throw new Error(\"Failed to scan trades: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Yuki Agent - Progressive streaming scan (SSE)\n    streamTrades (onEvent) {\n        const url = \"\".concat(API_BASE_URL, \"/api/agents/yuki/scan/stream\");\n        const es = new EventSource(url);\n        const safeParse = (raw)=>{\n            try {\n                if (typeof raw === \"string\") return JSON.parse(raw);\n                return raw;\n            } catch (e) {\n                return raw;\n            }\n        };\n        es.addEventListener(\"progress\", (e)=>onEvent({\n                type: \"progress\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"opportunity\", (e)=>onEvent({\n                type: \"opportunity\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"complete\", (e)=>onEvent({\n                type: \"complete\",\n                data: safeParse(e.data)\n            }));\n        es.addEventListener(\"error\", (e)=>onEvent({\n                type: \"error\",\n                data: safeParse(e.data || \"stream error\")\n            }));\n        // Return unsubscribe function\n        return ()=>es.close();\n    },\n    // Sakura Agent - Yield Opportunities\n    async getYieldOpportunities () {\n        try {\n            var _data_portfolio_recommendation_allocation, _data_portfolio_recommendation, _data_portfolio_recommendation1, _data_portfolio_recommendation2;\n            console.log(\"\\uD83C\\uDF38 Requesting Sakura yield analysis...\");\n            const response = await api.post(\"/api/agents/sakura/yield\", {\n                analysis_type: \"yield_farming\",\n                risk_preference: \"conservative\"\n            });\n            const data = response.data;\n            console.log(\"✅ Sakura analysis completed: \".concat(data.opportunities.length, \" yield opportunities found\"));\n            return {\n                opportunities: data.opportunities.map((opp)=>({\n                        id: opp.id,\n                        protocol: opp.protocol,\n                        asset: opp.asset,\n                        apy: opp.apy,\n                        tvl: opp.tvl,\n                        riskLevel: opp.risk_level,\n                        maturity: opp.maturity,\n                        minimumDeposit: opp.minimum_deposit,\n                        strategy: opp.strategy,\n                        projectedReturns: opp.projected_returns\n                    })),\n                totalTvlAnalyzed: data.total_tvl_analyzed || 0,\n                bestOpportunity: data.opportunities[0] || null,\n                portfolioRecommendation: {\n                    allocation: ((_data_portfolio_recommendation = data.portfolio_recommendation) === null || _data_portfolio_recommendation === void 0 ? void 0 : (_data_portfolio_recommendation_allocation = _data_portfolio_recommendation.allocation) === null || _data_portfolio_recommendation_allocation === void 0 ? void 0 : _data_portfolio_recommendation_allocation.map((alloc)=>({\n                            opportunity: {\n                                id: alloc.protocol.toLowerCase(),\n                                protocol: alloc.protocol,\n                                asset: \"Multi\",\n                                apy: alloc.apy_contribution * (100 / alloc.percentage),\n                                tvl: 0,\n                                riskLevel: \"LOW\",\n                                minimumDeposit: 100,\n                                strategy: \"Portfolio Allocation\",\n                                projectedReturns: {\n                                    monthly: alloc.apy_contribution / 12,\n                                    quarterly: alloc.apy_contribution / 4,\n                                    yearly: alloc.apy_contribution\n                                }\n                            },\n                            percentage: alloc.percentage\n                        }))) || [],\n                    totalProjectedApy: ((_data_portfolio_recommendation1 = data.portfolio_recommendation) === null || _data_portfolio_recommendation1 === void 0 ? void 0 : _data_portfolio_recommendation1.total_projected_apy) || 0,\n                    riskScore: ((_data_portfolio_recommendation2 = data.portfolio_recommendation) === null || _data_portfolio_recommendation2 === void 0 ? void 0 : _data_portfolio_recommendation2.risk_score) || 0.25\n                },\n                timestamp: data.timestamp || new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Yield analysis failed:\", error);\n            throw new Error(\"Failed to get yield opportunities: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    },\n    // Get integration status\n    async getStatus () {\n        try {\n            const response = await api.get(\"/api/agents/status\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to get status:\", error);\n            return null;\n        }\n    }\n};\n// Helper functions\nfunction getSpecialtyFromCapabilities(capabilities) {\n    if (capabilities.includes(\"token_analysis\")) return \"Token Analysis\";\n    if (capabilities.includes(\"market_scanning\")) return \"Trade Scanner\";\n    if (capabilities.includes(\"yield_optimization\")) return \"Yield Farming\";\n    return \"AI Analysis\";\n}\nfunction getActionLabel(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"Analyze Token\";\n        case \"yuki\":\n            return \"Find Trades\";\n        case \"sakura\":\n            return \"Get Yield Opportunities\";\n        default:\n            return \"Execute\";\n    }\n}\nfunction getResultType(agentId) {\n    switch(agentId){\n        case \"ryu\":\n            return \"AI Token Analysis Report\";\n        case \"yuki\":\n            return \"Market Opportunities\";\n        case \"sakura\":\n            return \"DeFi Yield Options\";\n        default:\n            return \"Analysis Results\";\n    }\n}\nfunction getDefaultAgents() {\n    return [\n        {\n            id: \"ryu\",\n            name: \"Ryu Agent\",\n            description: \"Professional token analysis with comprehensive AI scoring and risk assessment.\",\n            status: \"online\",\n            specialty: \"Token Analysis\",\n            actionLabel: \"Analyze Token\",\n            resultType: \"AI Token Analysis Report\"\n        },\n        {\n            id: \"yuki\",\n            name: \"Yuki Agent\",\n            description: \"Advanced trade scanner for high-frequency opportunities across 500+ trading pairs.\",\n            status: \"online\",\n            specialty: \"Trade Scanner\",\n            actionLabel: \"Find Trades\",\n            resultType: \"Market Opportunities\"\n        },\n        {\n            id: \"sakura\",\n            name: \"Sakura Agent\",\n            description: \"Conservative DeFi yield farming with Pendle integration and risk-adjusted returns.\",\n            status: \"online\",\n            specialty: \"Yield Farming\",\n            actionLabel: \"Get Yield Opportunities\",\n            resultType: \"DeFi Yield Options\"\n        }\n    ];\n}\nfunction calculateRiskReward(entry, target, stop, direction) {\n    try {\n        if (!entry || !target || !stop) return 0;\n        let reward;\n        let risk;\n        if (direction === \"LONG\") {\n            reward = target - entry;\n            risk = entry - stop;\n        } else {\n            reward = entry - target;\n            risk = stop - entry;\n        }\n        if (risk <= 0) return 0;\n        return reward / risk;\n    } catch (e) {\n        return 0;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SztZQUFVLE9BQU87UUFDdEI7WUFBUyxPQUFPO0lBQ2xCO0FBQ0Y7QUFFQSxTQUFTdkg7SUFDUCxPQUFPO1FBQ0w7WUFDRVgsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hHLGFBQWE7WUFDYkUsWUFBWTtRQUNkO1FBQ0E7WUFDRVQsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hHLGFBQWE7WUFDYkUsWUFBWTtRQUNkO1FBQ0E7WUFDRVQsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hHLGFBQWE7WUFDYkUsWUFBWTtRQUNkO0tBQ0Q7QUFDSDtBQUVBLFNBQVM4QixvQkFBb0I0RixLQUFhLEVBQUVDLE1BQWMsRUFBRUMsSUFBWSxFQUFFbEUsU0FBaUI7SUFDekYsSUFBSTtRQUNGLElBQUksQ0FBQ2dFLFNBQVMsQ0FBQ0MsVUFBVSxDQUFDQyxNQUFNLE9BQU87UUFFdkMsSUFBSUM7UUFDSixJQUFJcEY7UUFFSixJQUFJaUIsY0FBYyxRQUFRO1lBQ3hCbUUsU0FBU0YsU0FBU0Q7WUFDbEJqRixPQUFPaUYsUUFBUUU7UUFDakIsT0FBTztZQUNMQyxTQUFTSCxRQUFRQztZQUNqQmxGLE9BQU9tRixPQUFPRjtRQUNoQjtRQUVBLElBQUlqRixRQUFRLEdBQUcsT0FBTztRQUN0QixPQUFPb0YsU0FBU3BGO0lBQ2xCLEVBQUUsVUFBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBRUEsK0RBQWV4RSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9hcGkudHM/OTU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgQWdlbnQsIFRva2VuQW5hbHlzaXNSZXN1bHQsIFRyYWRlU2NhblJlc3VsdCwgWWllbGRBbmFseXNpc1Jlc3VsdCB9IGZyb20gJ0AvdHlwZXMvYWdlbnRzJztcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAxJztcblxuLy8gQ3JlYXRlIGF4aW9zIGluc3RhbmNlIHdpdGggZGVmYXVsdCBjb25maWdcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcbiAgLy8gRGlzYWJsZSBjbGllbnQtc2lkZSB0aW1lb3V0IHRvIGFsbG93IGxvbmctcnVubmluZyBZdWtpIHNjYW5zXG4gIHRpbWVvdXQ6IDAsXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9LFxufSk7XG5cbi8vIFJlc3BvbnNlIGludGVyY2VwdG9yIGZvciBlcnJvciBoYW5kbGluZ1xuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXG4gIChlcnJvcikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuZXhwb3J0IGNvbnN0IGFnZW50c1NlcnZpY2UgPSB7XG4gIC8vIEdldCBhbGwgYXZhaWxhYmxlIGFnZW50c1xuICBhc3luYyBnZXRBZ2VudHMoKTogUHJvbWlzZTxBZ2VudFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2FwaS9hZ2VudHMvc3RhdHVzJyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIGFnZW50IGRhdGEgdG8gZnJvbnRlbmQgZm9ybWF0XG4gICAgICBjb25zdCBhZ2VudHM6IEFnZW50W10gPSBPYmplY3QuZW50cmllcyhyZXNwb25zZS5kYXRhLmFnZW50cykubWFwKChba2V5LCBhZ2VudF06IFtzdHJpbmcsIGFueV0pID0+ICh7XG4gICAgICAgIGlkOiBrZXksXG4gICAgICAgIG5hbWU6IGFnZW50Lm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBhZ2VudC5kZXNjcmlwdGlvbixcbiAgICAgICAgc3RhdHVzOiBhZ2VudC5zdGF0dXMgPT09ICdvbmxpbmUnID8gJ29ubGluZScgYXMgY29uc3QgOiAnb2ZmbGluZScgYXMgY29uc3QsXG4gICAgICAgIHNwZWNpYWx0eTogZ2V0U3BlY2lhbHR5RnJvbUNhcGFiaWxpdGllcyhhZ2VudC5jYXBhYmlsaXRpZXMpLFxuICAgICAgICBhY3Rpb25MYWJlbDogZ2V0QWN0aW9uTGFiZWwoa2V5KSxcbiAgICAgICAgcmVzdWx0VHlwZTogZ2V0UmVzdWx0VHlwZShrZXkpLFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gYWdlbnRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWdlbnRzOicsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IGFnZW50cyBpZiBBUEkgZmFpbHNcbiAgICAgIHJldHVybiBnZXREZWZhdWx0QWdlbnRzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJ5dSBBZ2VudCAtIFRva2VuIEFuYWx5c2lzXG4gIGFzeW5jIGFuYWx5emVUb2tlbihzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8VG9rZW5BbmFseXNpc1Jlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBSZXF1ZXN0aW5nIFJ5dSBhbmFseXNpcyBmb3IgJHtzeW1ib2x9Li4uYCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3J5dS9hbmFseXplJywge1xuICAgICAgICBzeW1ib2w6IHN5bWJvbC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBhbmFseXNpc190eXBlOiAnY29tcHJlaGVuc2l2ZSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBSeXUgYW5hbHlzaXMgY29tcGxldGVkIGZvciAke3N5bWJvbH1gKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sOiBkYXRhLnN5bWJvbCxcbiAgICAgICAgYWN0aW9uOiBkYXRhLnJlY29tbWVuZGF0aW9uIHx8ICdIT0xEJyxcbiAgICAgICAgY29uZmlkZW5jZTogZGF0YS5jb25maWRlbmNlIHx8IDAuNSxcbiAgICAgICAgY3VycmVudFByaWNlOiBkYXRhLmN1cnJlbnRfcHJpY2UgfHwgMCxcbiAgICAgICAgZW50cnlSYW5nZToge1xuICAgICAgICAgIG1pbjogZGF0YS5lbnRyeV9sZXZlbHM/LmVudHJ5X3JhbmdlX2xvdyB8fCAwLFxuICAgICAgICAgIG1heDogZGF0YS5lbnRyeV9sZXZlbHM/LmVudHJ5X3JhbmdlX2hpZ2ggfHwgMCxcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0czoge1xuICAgICAgICAgIHRhcmdldDE6IGRhdGEuZW50cnlfbGV2ZWxzPy50YXJnZXRfMSB8fCAwLFxuICAgICAgICAgIHRhcmdldDI6IGRhdGEuZW50cnlfbGV2ZWxzPy50YXJnZXRfMixcbiAgICAgICAgICB0YXJnZXQzOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BMb3NzOiBkYXRhLmVudHJ5X2xldmVscz8uc3RvcF9sb3NzIHx8IDAsXG4gICAgICAgIHJpc2tSZXdhcmRSYXRpbzogY2FsY3VsYXRlUmlza1Jld2FyZChcbiAgICAgICAgICBkYXRhLmN1cnJlbnRfcHJpY2UsXG4gICAgICAgICAgZGF0YS5lbnRyeV9sZXZlbHM/LnRhcmdldF8xLFxuICAgICAgICAgIGRhdGEuZW50cnlfbGV2ZWxzPy5zdG9wX2xvc3MsXG4gICAgICAgICAgZGF0YS5yZWNvbW1lbmRhdGlvblxuICAgICAgICApLFxuICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgIHRlY2huaWNhbDogYFJTSTogJHtkYXRhLnRlY2huaWNhbF9hbmFseXNpcz8ucnNpXzE0Py50b0ZpeGVkKDEpIHx8ICdOL0EnfSwgTUFDRDogJHtkYXRhLnRlY2huaWNhbF9hbmFseXNpcz8ubWFjZF9saW5lPy50b0ZpeGVkKDQpIHx8ICdOL0EnfSwgVHJlbmQ6ICR7ZGF0YS50ZWNobmljYWxfYW5hbHlzaXM/LnRyZW5kIHx8ICdVbmtub3duJ31gLFxuICAgICAgICAgIGZ1bmRhbWVudGFsOiBgTWFya2V0IGNhcCBhbmFseXNpcyBhbmQgdm9sdW1lIGFzc2Vzc21lbnQgY29tcGxldGVkYCxcbiAgICAgICAgICBzZW50aW1lbnQ6IGBNYXJrZXQgc2VudGltZW50OiAke2RhdGEucmlza19hc3Nlc3NtZW50IHx8ICdOZXV0cmFsJ31gLFxuICAgICAgICAgIHJpc2s6IGBSaXNrIExldmVsOiAke2RhdGEucmlza19hc3Nlc3NtZW50IHx8ICdNZWRpdW0nfWAsXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3Jlczoge1xuICAgICAgICAgIHRlY2huaWNhbDogZGF0YS5zY29yZXM/LnRlY2huaWNhbCB8fCA3NSxcbiAgICAgICAgICBmdW5kYW1lbnRhbDogZGF0YS5zY29yZXM/Lm92ZXJhbGwgKiAwLjggfHwgNzAsXG4gICAgICAgICAgbW9tZW50dW06IGRhdGEuc2NvcmVzPy5tb21lbnR1bSB8fCA2NSxcbiAgICAgICAgICBzZW50aW1lbnQ6IGRhdGEuc2NvcmVzPy52b2x1bWUgKiAwLjcgfHwgNjAsXG4gICAgICAgICAgb3ZlcmFsbDogZGF0YS5zY29yZXM/Lm92ZXJhbGwgfHwgNjgsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBhbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xuXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgQVBJIGVycm9ycyBtb3JlIGdyYWNlZnVsbHlcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDQgJiYgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbCkge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UgZnJvbSA0MDQgcmVzcG9uc2VzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCk7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWwpIHtcbiAgICAgICAgLy8gSGFuZGxlIG90aGVyIEFQSSBlcnJvcnMgd2l0aCBkZXRhaWwgbWVzc2FnZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBuZXR3b3JrIG9yIG90aGVyIGVycm9yc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhbmFseXplICR7c3ltYm9sfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdOZXR3b3JrIEVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gWXVraSBBZ2VudCAtIFRyYWRlIFNjYW5uZXJcbiAgYXN5bmMgc2NhblRyYWRlcygpOiBQcm9taXNlPFRyYWRlU2NhblJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqhIFJlcXVlc3RpbmcgWXVraSB0cmFkZSBzY2FuLi4uJyk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3l1a2kvc2NhbicsIHtcbiAgICAgICAgc2Nhbl90eXBlOiAnb3Bwb3J0dW5pdGllcycsXG4gICAgICAgIHBhaXJzX2xpbWl0OiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBZdWtpIHNjYW4gY29tcGxldGVkOiAke2RhdGEub3Bwb3J0dW5pdGllc19mb3VuZH0gb3Bwb3J0dW5pdGllcyBmb3VuZGApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcHBvcnR1bml0aWVzOiBkYXRhLm9wcG9ydHVuaXRpZXMubWFwKChvcHA6IGFueSkgPT4gKHtcbiAgICAgICAgICBpZDogb3BwLmlkLFxuICAgICAgICAgIHN5bWJvbDogb3BwLnN5bWJvbCxcbiAgICAgICAgICBkaXJlY3Rpb246IG9wcC5kaXJlY3Rpb24sXG4gICAgICAgICAgY29uZmlkZW5jZTogb3BwLmNvbmZpZGVuY2UsXG4gICAgICAgICAgZW50cnlQcmljZTogb3BwLmVudHJ5X3ByaWNlLFxuICAgICAgICAgIHRhcmdldDE6IG9wcC50YXJnZXRfMSxcbiAgICAgICAgICB0YXJnZXQyOiBvcHAudGFyZ2V0XzIsXG4gICAgICAgICAgc3RvcExvc3M6IG9wcC5zdG9wX2xvc3MsXG4gICAgICAgICAgcmlza1Jld2FyZFJhdGlvOiBvcHAucmlza19yZXdhcmRfcmF0aW8sXG4gICAgICAgICAgdGltZUhvcml6b246IG9wcC50aW1lX2hvcml6b24sXG4gICAgICAgICAgcmVhc29uaW5nOiBvcHAucmVhc29uaW5nLFxuICAgICAgICAgIGtleUZhY3RvcnM6IG9wcC5rZXlfZmFjdG9ycyB8fCBbXSxcbiAgICAgICAgICBleHBpcmVzQXQ6IG9wcC5leHBpcmVzX2F0LFxuICAgICAgICB9KSksXG4gICAgICAgIHRvdGFsU2Nhbm5lZDogZGF0YS50b3RhbF9zY2FubmVkIHx8IDUwMCxcbiAgICAgICAgYmVzdE9wcG9ydHVuaXR5OiBkYXRhLm9wcG9ydHVuaXRpZXNbMF0gfHwgbnVsbCxcbiAgICAgICAgbWFya2V0Q29uZGl0aW9uOiBkYXRhLm1hcmtldF9jb25kaXRpb24gfHwgJ0FuYWx5emVkJyxcbiAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUcmFkZSBzY2FubmluZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2NhbiB0cmFkZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFl1a2kgQWdlbnQgLSBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgc2NhbiAoU1NFKVxuICBzdHJlYW1UcmFkZXMob25FdmVudDogKGV2dDogeyB0eXBlOiAncHJvZ3Jlc3MnIHwgJ29wcG9ydHVuaXR5JyB8ICdjb21wbGV0ZScgfCAnZXJyb3InOyBkYXRhOiBhbnkgfSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0vYXBpL2FnZW50cy95dWtpL3NjYW4vc3RyZWFtYDtcbiAgICBjb25zdCBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmwpO1xuXG4gICAgY29uc3Qgc2FmZVBhcnNlID0gKHJhdzogYW55KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZTogTWVzc2FnZUV2ZW50KSA9PiBvbkV2ZW50KHsgdHlwZTogJ3Byb2dyZXNzJywgZGF0YTogc2FmZVBhcnNlKGUuZGF0YSkgfSkpO1xuICAgIGVzLmFkZEV2ZW50TGlzdGVuZXIoJ29wcG9ydHVuaXR5JywgKGU6IE1lc3NhZ2VFdmVudCkgPT4gb25FdmVudCh7IHR5cGU6ICdvcHBvcnR1bml0eScsIGRhdGE6IHNhZmVQYXJzZShlLmRhdGEpIH0pKTtcbiAgICBlcy5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIChlOiBNZXNzYWdlRXZlbnQpID0+IG9uRXZlbnQoeyB0eXBlOiAnY29tcGxldGUnLCBkYXRhOiBzYWZlUGFyc2UoZS5kYXRhKSB9KSk7XG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZTogTWVzc2FnZUV2ZW50KSA9PiBvbkV2ZW50KHsgdHlwZTogJ2Vycm9yJywgZGF0YTogc2FmZVBhcnNlKChlIGFzIGFueSkuZGF0YSB8fCAnc3RyZWFtIGVycm9yJykgfSkpO1xuXG4gICAgLy8gUmV0dXJuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IGVzLmNsb3NlKCk7XG4gIH0sXG5cbiAgLy8gU2FrdXJhIEFnZW50IC0gWWllbGQgT3Bwb3J0dW5pdGllc1xuICBhc3luYyBnZXRZaWVsZE9wcG9ydHVuaXRpZXMoKTogUHJvbWlzZTxZaWVsZEFuYWx5c2lzUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4y4IFJlcXVlc3RpbmcgU2FrdXJhIHlpZWxkIGFuYWx5c2lzLi4uJyk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hcGkvYWdlbnRzL3Nha3VyYS95aWVsZCcsIHtcbiAgICAgICAgYW5hbHlzaXNfdHlwZTogJ3lpZWxkX2Zhcm1pbmcnLFxuICAgICAgICByaXNrX3ByZWZlcmVuY2U6ICdjb25zZXJ2YXRpdmUnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU2FrdXJhIGFuYWx5c2lzIGNvbXBsZXRlZDogJHtkYXRhLm9wcG9ydHVuaXRpZXMubGVuZ3RofSB5aWVsZCBvcHBvcnR1bml0aWVzIGZvdW5kYCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wcG9ydHVuaXRpZXM6IGRhdGEub3Bwb3J0dW5pdGllcy5tYXAoKG9wcDogYW55KSA9PiAoe1xuICAgICAgICAgIGlkOiBvcHAuaWQsXG4gICAgICAgICAgcHJvdG9jb2w6IG9wcC5wcm90b2NvbCxcbiAgICAgICAgICBhc3NldDogb3BwLmFzc2V0LFxuICAgICAgICAgIGFweTogb3BwLmFweSxcbiAgICAgICAgICB0dmw6IG9wcC50dmwsXG4gICAgICAgICAgcmlza0xldmVsOiBvcHAucmlza19sZXZlbCxcbiAgICAgICAgICBtYXR1cml0eTogb3BwLm1hdHVyaXR5LFxuICAgICAgICAgIG1pbmltdW1EZXBvc2l0OiBvcHAubWluaW11bV9kZXBvc2l0LFxuICAgICAgICAgIHN0cmF0ZWd5OiBvcHAuc3RyYXRlZ3ksXG4gICAgICAgICAgcHJvamVjdGVkUmV0dXJuczogb3BwLnByb2plY3RlZF9yZXR1cm5zLFxuICAgICAgICB9KSksXG4gICAgICAgIHRvdGFsVHZsQW5hbHl6ZWQ6IGRhdGEudG90YWxfdHZsX2FuYWx5emVkIHx8IDAsXG4gICAgICAgIGJlc3RPcHBvcnR1bml0eTogZGF0YS5vcHBvcnR1bml0aWVzWzBdIHx8IG51bGwsXG4gICAgICAgIHBvcnRmb2xpb1JlY29tbWVuZGF0aW9uOiB7XG4gICAgICAgICAgYWxsb2NhdGlvbjogZGF0YS5wb3J0Zm9saW9fcmVjb21tZW5kYXRpb24/LmFsbG9jYXRpb24/Lm1hcCgoYWxsb2M6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIG9wcG9ydHVuaXR5OiB7XG4gICAgICAgICAgICAgIGlkOiBhbGxvYy5wcm90b2NvbC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBwcm90b2NvbDogYWxsb2MucHJvdG9jb2wsXG4gICAgICAgICAgICAgIGFzc2V0OiAnTXVsdGknLFxuICAgICAgICAgICAgICBhcHk6IGFsbG9jLmFweV9jb250cmlidXRpb24gKiAoMTAwIC8gYWxsb2MucGVyY2VudGFnZSksXG4gICAgICAgICAgICAgIHR2bDogMCxcbiAgICAgICAgICAgICAgcmlza0xldmVsOiAnTE9XJyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgbWluaW11bURlcG9zaXQ6IDEwMCxcbiAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdQb3J0Zm9saW8gQWxsb2NhdGlvbicsXG4gICAgICAgICAgICAgIHByb2plY3RlZFJldHVybnM6IHtcbiAgICAgICAgICAgICAgICBtb250aGx5OiBhbGxvYy5hcHlfY29udHJpYnV0aW9uIC8gMTIsXG4gICAgICAgICAgICAgICAgcXVhcnRlcmx5OiBhbGxvYy5hcHlfY29udHJpYnV0aW9uIC8gNCxcbiAgICAgICAgICAgICAgICB5ZWFybHk6IGFsbG9jLmFweV9jb250cmlidXRpb24sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGVyY2VudGFnZTogYWxsb2MucGVyY2VudGFnZSxcbiAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgdG90YWxQcm9qZWN0ZWRBcHk6IGRhdGEucG9ydGZvbGlvX3JlY29tbWVuZGF0aW9uPy50b3RhbF9wcm9qZWN0ZWRfYXB5IHx8IDAsXG4gICAgICAgICAgcmlza1Njb3JlOiBkYXRhLnBvcnRmb2xpb19yZWNvbW1lbmRhdGlvbj8ucmlza19zY29yZSB8fCAwLjI1LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1lpZWxkIGFuYWx5c2lzIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgeWllbGQgb3Bwb3J0dW5pdGllczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gR2V0IGludGVncmF0aW9uIHN0YXR1c1xuICBhc3luYyBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2FwaS9hZ2VudHMvc3RhdHVzJyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0U3BlY2lhbHR5RnJvbUNhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKGNhcGFiaWxpdGllcy5pbmNsdWRlcygndG9rZW5fYW5hbHlzaXMnKSkgcmV0dXJuICdUb2tlbiBBbmFseXNpcyc7XG4gIGlmIChjYXBhYmlsaXRpZXMuaW5jbHVkZXMoJ21hcmtldF9zY2FubmluZycpKSByZXR1cm4gJ1RyYWRlIFNjYW5uZXInO1xuICBpZiAoY2FwYWJpbGl0aWVzLmluY2x1ZGVzKCd5aWVsZF9vcHRpbWl6YXRpb24nKSkgcmV0dXJuICdZaWVsZCBGYXJtaW5nJztcbiAgcmV0dXJuICdBSSBBbmFseXNpcyc7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbkxhYmVsKGFnZW50SWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWdlbnRJZCkge1xuICAgIGNhc2UgJ3J5dSc6IHJldHVybiAnQW5hbHl6ZSBUb2tlbic7XG4gICAgY2FzZSAneXVraSc6IHJldHVybiAnRmluZCBUcmFkZXMnO1xuICAgIGNhc2UgJ3Nha3VyYSc6IHJldHVybiAnR2V0IFlpZWxkIE9wcG9ydHVuaXRpZXMnO1xuICAgIGRlZmF1bHQ6IHJldHVybiAnRXhlY3V0ZSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzdWx0VHlwZShhZ2VudElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGFnZW50SWQpIHtcbiAgICBjYXNlICdyeXUnOiByZXR1cm4gJ0FJIFRva2VuIEFuYWx5c2lzIFJlcG9ydCc7XG4gICAgY2FzZSAneXVraSc6IHJldHVybiAnTWFya2V0IE9wcG9ydHVuaXRpZXMnO1xuICAgIGNhc2UgJ3Nha3VyYSc6IHJldHVybiAnRGVGaSBZaWVsZCBPcHRpb25zJztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ0FuYWx5c2lzIFJlc3VsdHMnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZ2VudHMoKTogQWdlbnRbXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6ICdyeXUnLFxuICAgICAgbmFtZTogJ1J5dSBBZ2VudCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb2Zlc3Npb25hbCB0b2tlbiBhbmFseXNpcyB3aXRoIGNvbXByZWhlbnNpdmUgQUkgc2NvcmluZyBhbmQgcmlzayBhc3Nlc3NtZW50LicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnVG9rZW4gQW5hbHlzaXMnLFxuICAgICAgYWN0aW9uTGFiZWw6ICdBbmFseXplIFRva2VuJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdBSSBUb2tlbiBBbmFseXNpcyBSZXBvcnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICd5dWtpJyxcbiAgICAgIG5hbWU6ICdZdWtpIEFnZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWR2YW5jZWQgdHJhZGUgc2Nhbm5lciBmb3IgaGlnaC1mcmVxdWVuY3kgb3Bwb3J0dW5pdGllcyBhY3Jvc3MgNTAwKyB0cmFkaW5nIHBhaXJzLicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnVHJhZGUgU2Nhbm5lcicsXG4gICAgICBhY3Rpb25MYWJlbDogJ0ZpbmQgVHJhZGVzJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdNYXJrZXQgT3Bwb3J0dW5pdGllcycsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3Nha3VyYScsXG4gICAgICBuYW1lOiAnU2FrdXJhIEFnZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29uc2VydmF0aXZlIERlRmkgeWllbGQgZmFybWluZyB3aXRoIFBlbmRsZSBpbnRlZ3JhdGlvbiBhbmQgcmlzay1hZGp1c3RlZCByZXR1cm5zLicsXG4gICAgICBzdGF0dXM6ICdvbmxpbmUnLFxuICAgICAgc3BlY2lhbHR5OiAnWWllbGQgRmFybWluZycsXG4gICAgICBhY3Rpb25MYWJlbDogJ0dldCBZaWVsZCBPcHBvcnR1bml0aWVzJyxcbiAgICAgIHJlc3VsdFR5cGU6ICdEZUZpIFlpZWxkIE9wdGlvbnMnLFxuICAgIH0sXG4gIF07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpc2tSZXdhcmQoZW50cnk6IG51bWJlciwgdGFyZ2V0OiBudW1iZXIsIHN0b3A6IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICB0cnkge1xuICAgIGlmICghZW50cnkgfHwgIXRhcmdldCB8fCAhc3RvcCkgcmV0dXJuIDA7XG5cbiAgICBsZXQgcmV3YXJkOiBudW1iZXI7XG4gICAgbGV0IHJpc2s6IG51bWJlcjtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdMT05HJykge1xuICAgICAgcmV3YXJkID0gdGFyZ2V0IC0gZW50cnk7XG4gICAgICByaXNrID0gZW50cnkgLSBzdG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXdhcmQgPSBlbnRyeSAtIHRhcmdldDtcbiAgICAgIHJpc2sgPSBzdG9wIC0gZW50cnk7XG4gICAgfVxuXG4gICAgaWYgKHJpc2sgPD0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHJld2FyZCAvIHJpc2s7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFwaTsiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImludGVyY2VwdG9ycyIsInJlc3BvbnNlIiwidXNlIiwiZXJyb3IiLCJjb25zb2xlIiwiUHJvbWlzZSIsInJlamVjdCIsImFnZW50c1NlcnZpY2UiLCJnZXRBZ2VudHMiLCJnZXQiLCJhZ2VudHMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZGF0YSIsIm1hcCIsImtleSIsImFnZW50IiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJzdGF0dXMiLCJzcGVjaWFsdHkiLCJnZXRTcGVjaWFsdHlGcm9tQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwiYWN0aW9uTGFiZWwiLCJnZXRBY3Rpb25MYWJlbCIsInJlc3VsdFR5cGUiLCJnZXRSZXN1bHRUeXBlIiwiZ2V0RGVmYXVsdEFnZW50cyIsImFuYWx5emVUb2tlbiIsInN5bWJvbCIsImxvZyIsInBvc3QiLCJ0b1VwcGVyQ2FzZSIsImFuYWx5c2lzX3R5cGUiLCJhY3Rpb24iLCJyZWNvbW1lbmRhdGlvbiIsImNvbmZpZGVuY2UiLCJjdXJyZW50UHJpY2UiLCJjdXJyZW50X3ByaWNlIiwiZW50cnlSYW5nZSIsIm1pbiIsImVudHJ5X2xldmVscyIsImVudHJ5X3JhbmdlX2xvdyIsIm1heCIsImVudHJ5X3JhbmdlX2hpZ2giLCJ0YXJnZXRzIiwidGFyZ2V0MSIsInRhcmdldF8xIiwidGFyZ2V0MiIsInRhcmdldF8yIiwidGFyZ2V0MyIsInVuZGVmaW5lZCIsInN0b3BMb3NzIiwic3RvcF9sb3NzIiwicmlza1Jld2FyZFJhdGlvIiwiY2FsY3VsYXRlUmlza1Jld2FyZCIsImFuYWx5c2lzIiwidGVjaG5pY2FsIiwidGVjaG5pY2FsX2FuYWx5c2lzIiwicnNpXzE0IiwidG9GaXhlZCIsIm1hY2RfbGluZSIsInRyZW5kIiwiZnVuZGFtZW50YWwiLCJzZW50aW1lbnQiLCJyaXNrX2Fzc2Vzc21lbnQiLCJyaXNrIiwic2NvcmVzIiwib3ZlcmFsbCIsIm1vbWVudHVtIiwidm9sdW1lIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZGV0YWlsIiwiRXJyb3IiLCJtZXNzYWdlIiwic2NhblRyYWRlcyIsInNjYW5fdHlwZSIsInBhaXJzX2xpbWl0Iiwib3Bwb3J0dW5pdGllc19mb3VuZCIsIm9wcG9ydHVuaXRpZXMiLCJvcHAiLCJkaXJlY3Rpb24iLCJlbnRyeVByaWNlIiwiZW50cnlfcHJpY2UiLCJyaXNrX3Jld2FyZF9yYXRpbyIsInRpbWVIb3Jpem9uIiwidGltZV9ob3Jpem9uIiwicmVhc29uaW5nIiwia2V5RmFjdG9ycyIsImtleV9mYWN0b3JzIiwiZXhwaXJlc0F0IiwiZXhwaXJlc19hdCIsInRvdGFsU2Nhbm5lZCIsInRvdGFsX3NjYW5uZWQiLCJiZXN0T3Bwb3J0dW5pdHkiLCJtYXJrZXRDb25kaXRpb24iLCJtYXJrZXRfY29uZGl0aW9uIiwic3RyZWFtVHJhZGVzIiwib25FdmVudCIsInVybCIsImVzIiwiRXZlbnRTb3VyY2UiLCJzYWZlUGFyc2UiLCJyYXciLCJKU09OIiwicGFyc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInR5cGUiLCJjbG9zZSIsImdldFlpZWxkT3Bwb3J0dW5pdGllcyIsInJpc2tfcHJlZmVyZW5jZSIsImxlbmd0aCIsInByb3RvY29sIiwiYXNzZXQiLCJhcHkiLCJ0dmwiLCJyaXNrTGV2ZWwiLCJyaXNrX2xldmVsIiwibWF0dXJpdHkiLCJtaW5pbXVtRGVwb3NpdCIsIm1pbmltdW1fZGVwb3NpdCIsInN0cmF0ZWd5IiwicHJvamVjdGVkUmV0dXJucyIsInByb2plY3RlZF9yZXR1cm5zIiwidG90YWxUdmxBbmFseXplZCIsInRvdGFsX3R2bF9hbmFseXplZCIsInBvcnRmb2xpb1JlY29tbWVuZGF0aW9uIiwiYWxsb2NhdGlvbiIsInBvcnRmb2xpb19yZWNvbW1lbmRhdGlvbiIsImFsbG9jIiwib3Bwb3J0dW5pdHkiLCJ0b0xvd2VyQ2FzZSIsImFweV9jb250cmlidXRpb24iLCJwZXJjZW50YWdlIiwibW9udGhseSIsInF1YXJ0ZXJseSIsInllYXJseSIsInRvdGFsUHJvamVjdGVkQXB5IiwidG90YWxfcHJvamVjdGVkX2FweSIsInJpc2tTY29yZSIsInJpc2tfc2NvcmUiLCJnZXRTdGF0dXMiLCJpbmNsdWRlcyIsImFnZW50SWQiLCJlbnRyeSIsInRhcmdldCIsInN0b3AiLCJyZXdhcmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/api.ts\n"));

/***/ })

});